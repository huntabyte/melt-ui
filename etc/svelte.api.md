## API Report File for "@melt-ui/svelte"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="svelte" />

import { Action } from 'svelte/action';
import type { ActionReturn } from 'svelte/action';
import type { Boundary } from '@floating-ui/dom';
import { Invalidator } from 'svelte/store';
import { Readable } from 'svelte/store';
import { Stores } from 'svelte/store';
import { StoresValues } from 'svelte/store';
import { Subscriber } from 'svelte/store';
import { Unsubscriber } from 'svelte/store';
import { Updater } from 'svelte/store';
import { Writable } from 'svelte/store';

// Warning: (ae-forgotten-export) The symbol "BuilderReturn" needs to be exported by the entry point index.d.ts
//
// @public
export type Accordion<Multiple extends boolean = false> = BuilderReturn<typeof createAccordion<Multiple>>;

// Warning: (ae-forgotten-export) The symbol "MeltComponentEvents" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "AccordionEvents" needs to be exported by the entry point index.d.ts
//
// @public
export type AccordionComponentEvents = MeltComponentEvents<AccordionEvents>;

// @public
export type AccordionElements<Multiple extends boolean = false> = BuilderReturn<typeof createAccordion<Multiple>>['elements'];

// @public
export type AccordionHeadingProps = {
    level: 1 | 2 | 3 | 4 | 5 | 6;
} | number;

// @public
export type AccordionHelpers<Multiple extends boolean = false> = BuilderReturn<typeof createAccordion<Multiple>>['helpers'];

// @public
export type AccordionItemProps = {
    value: string;
    disabled?: boolean;
} | string;

// @public
export type AccordionOptions<Multiple extends boolean = false> = BuilderReturn<typeof createAccordion<Multiple>>['options'];

// @public
export type AccordionStates<Multiple extends boolean = false> = BuilderReturn<typeof createAccordion<Multiple>>['states'];

// @public
export type ActiveType = 'none' | 'lowest' | 'highest' | 'all' | 'lowest-parents' | 'highest-parents';

// @public (undocumented)
export type AddTag = (tag: string) => (Tag | string | never) | Promise<Tag | string | never>;

// @public (undocumented)
export type AddToastProps<T = object> = CreateToasterProps & {
    data: T;
};

// @public (undocumented)
export type Avatar = BuilderReturn<typeof createAvatar>;

// @public (undocumented)
export type AvatarElements = Avatar['elements'];

// @public (undocumented)
export type AvatarOptions = Avatar['options'];

// @public (undocumented)
export type AvatarStates = Avatar['states'];

// @public (undocumented)
export type Blur = 'nothing' | 'add' | 'clear';

// @public (undocumented)
export type Checkbox = BuilderReturn<typeof createCheckbox>;

// Warning: (ae-forgotten-export) The symbol "CheckboxEvents" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type CheckboxComponentEvents = MeltComponentEvents<CheckboxEvents>;

// @public (undocumented)
export type CheckboxElements = Checkbox['elements'];

// @public (undocumented)
export type CheckboxHelpers = Checkbox['helpers'];

// @public (undocumented)
export type CheckboxOptions = Checkbox['options'];

// @public (undocumented)
export type CheckboxStates = Checkbox['states'];

// @public (undocumented)
export type Collapsible = BuilderReturn<typeof createCollapsible>;

// Warning: (ae-forgotten-export) The symbol "CollapsibleEvents" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type CollapsibleComponentEvents = MeltComponentEvents<CollapsibleEvents>;

// @public (undocumented)
export type CollapsibleElements = Collapsible['elements'];

// @public (undocumented)
export type CollapsibleOptions = Collapsible['options'];

// @public (undocumented)
export type CollapsibleStates = Collapsible['states'];

// @public (undocumented)
export type Combobox<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = BuilderReturn<typeof createCombobox<Value, Multiple, S>>;

// Warning: (ae-forgotten-export) The symbol "ComboboxEvents" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ComboboxComponentEvents = MeltComponentEvents<ComboboxEvents>;

// @public (undocumented)
export type ComboboxElements<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = Combobox<Value, Multiple, S>['elements'];

// @public (undocumented)
export type ComboboxHelpers<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = Combobox<Value, Multiple, S>['helpers'];

// @public (undocumented)
export type ComboboxOptions<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = Combobox<Value, Multiple, S>['options'];

// @public (undocumented)
export type ComboboxStates<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = Combobox<Value, Multiple, S>['states'];

// @public (undocumented)
export type ContextMenu = BuilderReturn<typeof createContextMenu>;

// @public (undocumented)
export type ContextMenuBuilders = ContextMenu['builders'];

// Warning: (ae-forgotten-export) The symbol "ContextMenuEvents" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ContextMenuComponentEvents = MeltComponentEvents<ContextMenuEvents>;

// @public (undocumented)
export type ContextMenuElements = ContextMenu['elements'];

// Warning: (ae-forgotten-export) The symbol "_Menu" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ContextMenuItemProps = _Menu['item'];

// @public (undocumented)
export type ContextMenuOptions = ContextMenu['options'];

// @public (undocumented)
export type ContextMenuRadioGroup = BuilderReturn<ContextMenuBuilders['createMenuRadioGroup']>;

// @public (undocumented)
export type ContextMenuRadioGroupElements = ContextMenuRadioGroup['elements'];

// @public (undocumented)
export type ContextMenuRadioGroupHelpers = ContextMenuRadioGroup['helpers'];

// @public (undocumented)
export type ContextMenuRadioGroupStates = ContextMenuRadioGroup['states'];

// @public (undocumented)
export type ContextMenuRadioItemActionProps = _Menu['radioItemAction'];

// @public (undocumented)
export type ContextMenuRadioItemProps = _Menu['radioItem'];

// @public (undocumented)
export type ContextMenuStates = ContextMenu['states'];

// @public (undocumented)
export type ContextMenuSubmenu = BuilderReturn<ContextMenuBuilders['createSubmenu']>;

// @public (undocumented)
export type ContextMenuSubmenuElements = ContextMenuSubmenu['elements'];

// @public (undocumented)
export type ContextMenuSubmenuOptions = ContextMenuSubmenu['options'];

// @public (undocumented)
export type ContextMenuSubmenuStates = ContextMenuSubmenu['states'];

// @public
export const createAccordion: <Multiple extends boolean = false>(props?: CreateAccordionProps<Multiple> | undefined) => {
    ids: {
        root: string;
    };
    elements: {
        root: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => {
        'data-melt-id': string;
        }, string>;
        item: ExplicitBuilderReturn<    {
        update: (updater: Updater<string | string[] | undefined>, sideEffect?: ((newValue: string | string[] | undefined) => void) | undefined) => void;
        set: (this: void, value: string | string[] | undefined) => void;
        subscribe(this: void, run: Subscriber<string | string[] | undefined>, invalidate?: Invalidator<string | string[] | undefined> | undefined): Unsubscriber;
        }, Action<any, any, Record<never, any>>, ($value: string | string[] | undefined) => (props: AccordionItemProps) => {
        'data-state': string;
        'data-disabled': boolean | undefined;
        }, string>;
        trigger: ExplicitBuilderReturn<[{
        update: (updater: Updater<string | string[] | undefined>, sideEffect?: ((newValue: string | string[] | undefined) => void) | undefined) => void;
        set: (this: void, value: string | string[] | undefined) => void;
        subscribe(this: void, run: Subscriber<string | string[] | undefined>, invalidate?: Invalidator<string | string[] | undefined> | undefined): Unsubscriber;
        }, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<AccordionEvents['trigger']>, ([$value, $disabled]: [string | string[] | undefined, boolean]) => (props: AccordionItemProps) => {
        disabled: boolean | undefined;
        'aria-expanded': boolean;
        'aria-disabled': boolean;
        'data-disabled': boolean | undefined;
        'data-value': string;
        'data-state': string;
        }, string>;
        content: ExplicitBuilderReturn<[{
        update: (updater: Updater<string | string[] | undefined>, sideEffect?: ((newValue: string | string[] | undefined) => void) | undefined) => void;
        set: (this: void, value: string | string[] | undefined) => void;
        subscribe(this: void, run: Subscriber<string | string[] | undefined>, invalidate?: Invalidator<string | string[] | undefined> | undefined): Unsubscriber;
        }, Writable<boolean>, Writable<boolean>], (node: HTMLElement) => void, ([$value, $disabled, $forceVisible]: [string | string[] | undefined, boolean, boolean]) => (props: AccordionItemProps) => {
        'data-state': string;
        'data-disabled': boolean | undefined;
        'data-value': string;
        hidden: boolean | undefined;
        style: string;
        }, string>;
        heading: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => (props: AccordionHeadingProps) => {
        role: string;
        'aria-level': number;
        'data-heading-level': number;
        }, string>;
    };
    states: {
        value: Writable<WhenTrue<Multiple, string[], string, string | string[]> | undefined>;
    };
    helpers: {
        isSelected: Readable<(key: string) => boolean>;
    };
    options: {
        disabled: Writable<boolean>;
        forceVisible: Writable<boolean>;
        multiple: Writable<false | Multiple>;
    };
};

// @public
export type CreateAccordionProps<Multiple extends boolean = false> = {
    multiple?: Multiple;
    disabled?: boolean;
    forceVisible?: boolean;
    defaultValue?: AccordionValue<Multiple>;
    value?: Writable<AccordionValue<Multiple> | undefined>;
    onValueChange?: ChangeFn<AccordionValue<Multiple> | undefined>;
};

// @public (undocumented)
export const createAvatar: (props?: CreateAvatarProps) => {
    elements: {
        image: ExplicitBuilderReturn<[Writable<string>, {
        update: (updater: Updater<"error" | "loading" | "loaded">, sideEffect?: ((newValue: "error" | "loading" | "loaded") => void) | undefined) => void;
        set: (this: void, value: "error" | "loading" | "loaded") => void;
        subscribe(this: void, run: Subscriber<"error" | "loading" | "loaded">, invalidate?: Invalidator<"error" | "loading" | "loaded"> | undefined): Unsubscriber;
        }], Action<any, any, Record<never, any>>, ([$src, $loadingStatus]: [string, "error" | "loading" | "loaded"]) => {
        src: string;
        style: string;
        }, "avatar-image">;
        fallback: ExplicitBuilderReturn<[{
        update: (updater: Updater<"error" | "loading" | "loaded">, sideEffect?: ((newValue: "error" | "loading" | "loaded") => void) | undefined) => void;
        set: (this: void, value: "error" | "loading" | "loaded") => void;
        subscribe(this: void, run: Subscriber<"error" | "loading" | "loaded">, invalidate?: Invalidator<"error" | "loading" | "loaded"> | undefined): Unsubscriber;
        }], Action<any, any, Record<never, any>>, ([$loadingStatus]: ["error" | "loading" | "loaded"]) => {
        style: string | undefined;
        hidden: boolean | undefined;
        }, "avatar-fallback">;
    };
    states: {
        loadingStatus: {
            update: (updater: Updater<"error" | "loading" | "loaded">, sideEffect?: ((newValue: "error" | "loading" | "loaded") => void) | undefined) => void;
            set: (this: void, value: "error" | "loading" | "loaded") => void;
            subscribe(this: void, run: Subscriber<"error" | "loading" | "loaded">, invalidate?: Invalidator<"error" | "loading" | "loaded"> | undefined): Unsubscriber;
        };
    };
    options: {
        src: Writable<string>;
        delayMs: Writable<number>;
    };
};

// @public (undocumented)
export type CreateAvatarProps = {
    src: string;
    delayMs?: number;
    loadingStatus?: Writable<ImageLoadingStatus>;
    onLoadingStatusChange?: ChangeFn<ImageLoadingStatus>;
};

// @public (undocumented)
export function createCheckbox(props?: CreateCheckboxProps): {
    elements: {
        root: ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
        set: (this: void, value: boolean | "indeterminate") => void;
        subscribe(this: void, run: Subscriber<boolean | "indeterminate">, invalidate?: Invalidator<boolean | "indeterminate"> | undefined): Unsubscriber;
        }, Writable<boolean>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<CheckboxEvents['root']>, ([$checked, $disabled, $required]: [boolean | "indeterminate", boolean, boolean]) => {
        readonly 'data-disabled': true | undefined;
        readonly 'data-state': "indeterminate" | "checked" | "unchecked";
        readonly type: "button";
        readonly role: "checkbox";
        readonly 'aria-checked': boolean | "mixed";
        readonly 'aria-required': boolean;
        }, "checkbox">;
        input: ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
        set: (this: void, value: boolean | "indeterminate") => void;
        subscribe(this: void, run: Subscriber<boolean | "indeterminate">, invalidate?: Invalidator<boolean | "indeterminate"> | undefined): Unsubscriber;
        }, Writable<string | undefined>, Writable<string>, Writable<boolean>, Writable<boolean>], Action<any, any, Record<never, any>>, ([$checked, $name, $value, $required, $disabled]: [boolean | "indeterminate", string | undefined, string, boolean, boolean]) => {
        readonly type: "checkbox";
        readonly 'aria-hidden': true;
        readonly hidden: true;
        readonly tabindex: -1;
        readonly name: string | undefined;
        readonly value: string;
        readonly checked: boolean;
        readonly required: boolean;
        readonly disabled: true | undefined;
        readonly style: string;
        }, "checkbox-input">;
    };
    states: {
        checked: {
            update: (updater: Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
            set: (this: void, value: boolean | "indeterminate") => void;
            subscribe(this: void, run: Subscriber<boolean | "indeterminate">, invalidate?: Invalidator<boolean | "indeterminate"> | undefined): Unsubscriber;
        };
    };
    helpers: {
        isIndeterminate: Readable<boolean>;
        isChecked: Readable<boolean>;
    };
    options: {
        disabled: Writable<boolean>;
        value: Writable<string>;
        name: Writable<string | undefined>;
        required: Writable<boolean>;
        onCheckedChange?: Writable<ChangeFn<boolean | "indeterminate"> | undefined> | undefined;
    };
};

// @public (undocumented)
export type CreateCheckboxProps = {
    disabled?: boolean;
    required?: boolean;
    name?: string;
    value?: string;
    defaultChecked?: boolean | 'indeterminate';
    checked?: Writable<boolean | 'indeterminate'>;
    onCheckedChange?: ChangeFn<boolean | 'indeterminate'>;
};

// @public (undocumented)
export function createCollapsible(props?: CreateCollapsibleProps): {
    elements: {
        root: ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, Writable<boolean>], Action<any, any, Record<never, any>>, ([$open, $disabled]: [boolean, boolean]) => {
        'data-state': string;
        'data-disabled': boolean | undefined;
        }, string>;
        trigger: ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<CollapsibleEvents['trigger']>, ([$open, $disabled]: [boolean, boolean]) => {
        readonly 'data-state': "open" | "closed";
        readonly 'data-disabled': true | undefined;
        readonly disabled: true | undefined;
        }, string>;
        content: ExplicitBuilderReturn<[Readable<boolean>, Writable<boolean>], Action<any, any, Record<never, any>>, ([$isVisible, $disabled]: [boolean, boolean]) => {
        'data-state': string;
        'data-disabled': boolean | undefined;
        hidden: boolean | undefined;
        style: string;
        }, string>;
    };
    states: {
        open: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
    };
    options: {
        disabled: Writable<boolean>;
        forceVisible: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreateCollapsibleProps = {
    disabled?: boolean;
    forceVisible?: boolean;
    defaultOpen?: boolean;
    open?: Writable<boolean>;
    onOpenChange?: ChangeFn<boolean>;
};

// @public
export function createCombobox<Value, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>>(props?: CreateComboboxProps<Value, Multiple, S>): {
    elements: {
        input: ExplicitBuilderReturn<[ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, Writable<HTMLElement | null>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<"input" | "click" | "keydown">, ([$open, $highlightedItem, $disabled]: [boolean, HTMLElement | null, boolean]) => {
        readonly 'aria-activedescendant': string | undefined;
        readonly 'aria-autocomplete': "list";
        readonly 'aria-controls': string;
        readonly 'aria-expanded': boolean;
        readonly 'aria-labelledby': string;
        readonly 'data-melt-id': string;
        readonly id: string;
        readonly role: "combobox";
        readonly disabled: true | undefined;
        }, string>, Writable<string>], (node: HTMLInputElement) => MeltActionReturn<ComboboxEvents['input']>, ([$trigger, $inputValue]: [{
        readonly 'aria-activedescendant': string | undefined;
        readonly 'aria-autocomplete': "list";
        readonly 'aria-controls': string;
        readonly 'aria-expanded': boolean;
        readonly 'aria-labelledby': string;
        readonly 'data-melt-id': string;
        readonly id: string;
        readonly role: "combobox";
        readonly disabled: true | undefined;
        } & {
        [x: `data-melt-${string}`]: "";
        } & {
        action: (node: HTMLElement) => MeltActionReturn<"input" | "click" | "keydown">;
        }, string]) => {
        readonly role: "combobox";
        readonly value: string;
        readonly disabled: true | undefined;
        readonly 'aria-expanded': boolean;
        readonly 'aria-controls': string;
        readonly 'aria-activedescendant': string | undefined;
        readonly 'aria-autocomplete': "list";
        readonly 'aria-labelledby': string;
        readonly id: string;
        }, string>;
        trigger: ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, Writable<HTMLElement | null>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<"input" | "click" | "keydown">, ([$open, $highlightedItem, $disabled]: [boolean, HTMLElement | null, boolean]) => {
        readonly 'aria-activedescendant': string | undefined;
        readonly 'aria-autocomplete': "list";
        readonly 'aria-controls': string;
        readonly 'aria-expanded': boolean;
        readonly 'aria-labelledby': string;
        readonly 'data-melt-id': string;
        readonly id: string;
        readonly role: "combobox";
        readonly disabled: true | undefined;
        }, string>;
        option: ExplicitBuilderReturn<[{
        update: (updater: Updater<S | undefined>, sideEffect?: ((newValue: S | undefined) => void) | undefined) => void;
        set: (this: void, value: S | undefined) => void;
        subscribe(this: void, run: Subscriber<S | undefined>, invalidate?: Invalidator<S | undefined> | undefined): Unsubscriber;
        }], (node: HTMLElement) => MeltActionReturn<"click" | "pointermove">, ([$selected]: [S | undefined]) => (props: ListboxOptionProps<unknown>) => {
        readonly 'data-value': string;
        readonly 'data-label': string | undefined;
        readonly 'data-disabled': true | undefined;
        readonly 'aria-disabled': true | undefined;
        readonly 'aria-selected': boolean;
        readonly 'data-selected': "" | undefined;
        readonly id: string;
        readonly role: "option";
        readonly style: string;
        }, string>;
        menu: ExplicitBuilderReturn<[Readable<boolean>], (node: HTMLElement) => MeltActionReturn<"pointerleave">, ([$isVisible]: [boolean]) => {
        readonly hidden: true | undefined;
        readonly id: string;
        readonly role: "listbox";
        readonly style: string;
        }, string>;
        label: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<"mousedown">, () => {
        id: string;
        for: string;
        }, string>;
        hiddenInput: ExplicitBuilderReturn<[{
        update: (updater: Updater<S | undefined>, sideEffect?: ((newValue: S | undefined) => void) | undefined) => void;
        set: (this: void, value: S | undefined) => void;
        subscribe(this: void, run: Subscriber<S | undefined>, invalidate?: Invalidator<S | undefined> | undefined): Unsubscriber;
        }, Writable<boolean>, Writable<string | undefined>], Action<any, any, Record<never, any>>, ([$selected, $required, $name]: [S | undefined, boolean, string | undefined]) => {
        required: boolean | undefined;
        value: unknown;
        name: string | undefined;
        type: string;
        'aria-hidden': boolean;
        hidden: boolean;
        tabIndex: number;
        style: string;
        }, string>;
        arrow: ExplicitBuilderReturn<Writable<number | undefined>, Action<any, any, Record<never, any>>, ($arrowSize: number | undefined) => {
        'data-arrow': boolean;
        style: string;
        }, string>;
    };
    states: {
        touchedInput: Writable<boolean>;
        inputValue: Writable<string>;
        open: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
        selected: {
            update: (updater: Updater<S | undefined>, sideEffect?: ((newValue: S | undefined) => void) | undefined) => void;
            set: (this: void, value: S | undefined) => void;
            subscribe(this: void, run: Subscriber<S | undefined>, invalidate?: Invalidator<S | undefined> | undefined): Unsubscriber;
        };
        highlighted: Readable<ListboxOption<unknown> | undefined>;
    };
    ids: {
        trigger: string;
        menu: string;
        label: string;
    };
    helpers: {
        isSelected: Readable<(value: unknown) => boolean>;
        isHighlighted: Readable<(item: unknown) => boolean>;
        closeMenu: () => void;
    };
    options: {
        multiple: Writable<Multiple>;
        disabled: Writable<boolean>;
        forceVisible: Writable<boolean>;
        name: Writable<string | undefined>;
        required: Writable<boolean>;
        onOpenChange?: Writable<ChangeFn<boolean> | undefined> | undefined;
        preventScroll: Writable<boolean>;
        portal: Writable<string | HTMLElement | null | undefined>;
        positioning: Writable<FloatingConfig | {
        placement: "bottom";
        sameWidth: true;
        }>;
        arrowSize?: Writable<number | undefined> | undefined;
        scrollAlignment: Writable<"center" | "nearest">;
        loop: Writable<boolean>;
        defaultSelected?: Writable<S | undefined> | undefined;
        selected?: Writable<Writable<S> | undefined> | undefined;
        onSelectedChange?: Writable<ChangeFn<S | undefined> | undefined> | undefined;
        closeOnOutsideClick: Writable<boolean>;
        closeOnEscape: Writable<boolean>;
        typeahead: Writable<boolean>;
    };
};

// Warning: (ae-forgotten-export) The symbol "CreateListboxProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type CreateComboboxProps<Value, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = Omit<CreateListboxProps<Value, Multiple, S>, 'builder' | 'typeahead'>;

// @public (undocumented)
export function createContextMenu(props?: CreateContextMenuProps): {
    elements: {
        menu: ExplicitBuilderReturn<[Readable<boolean>, Writable<string | HTMLElement | null | undefined>], (node: HTMLElement) => MeltActionReturn<ContextMenuEvents['menu']>, ([$isVisible, $portal]: [boolean, string | HTMLElement | null | undefined]) => {
        readonly role: "menu";
        readonly hidden: true | undefined;
        readonly style: string;
        readonly id: string;
        readonly 'aria-labelledby': string;
        readonly 'data-state': "open" | "closed";
        readonly 'data-portal': "" | undefined;
        readonly tabindex: -1;
        }, string>;
        trigger: ExplicitBuilderReturn<    {
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, (node: HTMLElement) => MeltActionReturn<ContextMenuEvents['trigger']>, ($rootOpen: boolean) => {
        readonly 'aria-controls': string;
        readonly 'aria-expanded': boolean;
        readonly 'data-state': "open" | "closed";
        readonly id: string;
        readonly style: string;
        }, string>;
        item: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerdown" | "pointerleave" | "pointermove">, () => {
        role: string;
        tabindex: number;
        'data-orientation': string;
        }, string>;
        arrow: ExplicitBuilderReturn<Writable<number | undefined>, Action<any, any, Record<never, any>>, ($arrowSize: number | undefined) => {
        'data-arrow': boolean;
        style: string;
        }, string>;
        separator: ExplicitBuilderReturn<[Writable<Orientation>, Writable<boolean>], Action<any, any, Record<never, any>>, ([$orientation, $decorative]: [Orientation, boolean]) => {
        role: string;
        'aria-orientation': "vertical" | undefined;
        'aria-hidden': boolean;
        'data-orientation': Orientation;
        }, "separator">;
        group: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => (groupId: string) => {
        role: string;
        'aria-labelledby': string;
        }, string>;
        groupLabel: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => (groupId: string) => {
        id: string;
        }, string>;
    };
    states: {
        open: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
    };
    builders: {
        createSubmenu: (args?: _CreateSubmenuProps | undefined) => {
            ids: {
                menu: string;
                trigger: string;
            };
            elements: {
                subTrigger: ExplicitBuilderReturn<[Writable<boolean>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerleave" | "pointermove">, ([$subOpen, $disabled]: [boolean, boolean]) => {
                readonly role: "menuitem";
                readonly id: string;
                readonly tabindex: -1;
                readonly 'aria-controls': string;
                readonly 'aria-expanded': boolean;
                readonly 'data-state': "open" | "closed";
                readonly 'data-disabled': true | undefined;
                readonly 'aria-haspopop': "menu";
                }, string>;
                subMenu: ExplicitBuilderReturn<[Readable<boolean>], (node: HTMLElement) => MeltActionReturn<"focusout" | "keydown" | "pointermove">, ([$subIsVisible]: [boolean]) => {
                readonly role: "menu";
                readonly hidden: true | undefined;
                readonly style: string;
                readonly id: string;
                readonly 'aria-labelledby': string;
                readonly 'data-state': "open" | "closed";
                readonly tabindex: -1;
                }, string>;
                subArrow: ExplicitBuilderReturn<Writable<number>, Action<any, any, Record<never, any>>, ($arrowSize: number) => {
                'data-arrow': boolean;
                style: string;
                }, string>;
            };
            states: {
                subOpen: Writable<boolean>;
            };
            options: {
                positioning: Writable<FloatingConfig | {
                placement: "right-start";
                gutter: number;
                }>;
                arrowSize: Writable<number>;
                disabled: Writable<boolean>;
                preventScroll: Writable<true>;
                closeOnEscape: Writable<true>;
                closeOnOutsideClick: Writable<true>;
                portal: Writable<string>;
                loop: Writable<false>;
                dir: Writable<"ltr">;
                defaultOpen: Writable<false>;
                typeahead: Writable<true>;
            };
        };
        createCheckboxItem: (props?: _CheckboxItemProps | undefined) => {
            elements: {
                checkboxItem: ExplicitBuilderReturn<[{
                update: (updater: Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
                set: (this: void, value: boolean | "indeterminate") => void;
                subscribe(this: void, run: Subscriber<boolean | "indeterminate">, invalidate?: Invalidator<boolean | "indeterminate"> | undefined): Unsubscriber;
                }, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerdown" | "pointerleave" | "pointermove">, ([$checked, $disabled]: [boolean | "indeterminate", boolean]) => {
                readonly role: "menuitemcheckbox";
                readonly tabindex: -1;
                readonly 'data-orientation': "vertical";
                readonly 'aria-checked': "true" | "mixed" | "false";
                readonly 'data-disabled': true | undefined;
                readonly 'data-state': "indeterminate" | "checked" | "unchecked";
                }, string>;
            };
            states: {
                checked: {
                    update: (updater: Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
                    set: (this: void, value: boolean | "indeterminate") => void;
                    subscribe(this: void, run: Subscriber<boolean | "indeterminate">, invalidate?: Invalidator<boolean | "indeterminate"> | undefined): Unsubscriber;
                };
            };
            options: {
                disabled: Writable<boolean>;
            };
        };
        createMenuRadioGroup: (args?: _CreateRadioGroupProps) => {
            elements: {
                radioGroup: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => {
                role: string;
                }, string>;
                radioItem: ExplicitBuilderReturn<[{
                update: (updater: Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
                set: (this: void, value: string | null) => void;
                subscribe(this: void, run: Subscriber<string | null>, invalidate?: Invalidator<string | null> | undefined): Unsubscriber;
                }], (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerdown" | "pointerleave" | "pointermove">, ([$value]: [string | null]) => (itemProps: _RadioItemProps) => {
                disabled: boolean;
                role: string;
                'data-state': string;
                'aria-checked': boolean;
                'data-disabled': boolean | undefined;
                'data-value': string;
                'data-orientation': string;
                tabindex: number;
                }, string>;
            };
            states: {
                value: {
                    update: (updater: Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
                    set: (this: void, value: string | null) => void;
                    subscribe(this: void, run: Subscriber<string | null>, invalidate?: Invalidator<string | null> | undefined): Unsubscriber;
                };
            };
            helpers: {
                isChecked: Readable<(itemValue: string) => boolean>;
            };
        };
    };
    options: {
        positioning: Writable<FloatingConfig | {
        placement: "bottom-start";
        }>;
        arrowSize: Writable<number>;
        dir: Writable<TextDirection>;
        preventScroll: Writable<boolean>;
        closeOnEscape: Writable<boolean>;
        portal: Writable<string | HTMLElement | null | undefined>;
        closeOnOutsideClick: Writable<boolean>;
        loop: Writable<boolean>;
        defaultOpen: Writable<boolean>;
        open?: Writable<Writable<boolean> | undefined> | undefined;
        onOpenChange?: Writable<ChangeFn<boolean> | undefined> | undefined;
        forceVisible: Writable<boolean>;
        typeahead: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreateContextMenuCheckboxItemProps = _Menu['checkboxItem'];

// @public (undocumented)
export type CreateContextMenuProps = _Menu['builder'];

// @public (undocumented)
export type CreateContextMenuRadioGroupProps = _Menu['radioGroup'];

// @public (undocumented)
export type CreateContextSubmenuProps = _Menu['submenu'];

// @public (undocumented)
export function createDialog(props?: CreateDialogProps): {
    ids: {
        content: string;
        title: string;
        description: string;
        trigger: string;
    };
    elements: {
        content: ExplicitBuilderReturn<[Readable<boolean>], (node: HTMLElement) => {
        destroy: () => void;
        }, ([$isVisible]: [boolean]) => {
        id: string;
        role: "dialog" | "alertdialog";
        'aria-describedby': string;
        'aria-labelledby': string;
        'data-state': string;
        tabindex: number;
        hidden: boolean | undefined;
        style: string;
        }, string>;
        trigger: ExplicitBuilderReturn<    {
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, (node: HTMLElement) => MeltActionReturn<DialogEvents['trigger']>, ($open: boolean) => {
        readonly id: string;
        readonly 'aria-haspopup': "dialog";
        readonly 'aria-expanded': boolean;
        readonly 'aria-controls': string;
        readonly type: "button";
        }, string>;
        title: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => {
        id: string;
        }, string>;
        description: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => {
        id: string;
        }, string>;
        overlay: ExplicitBuilderReturn<[Readable<boolean>], <Node_1 extends any>(node: HTMLElement) => {
        destroy(): void;
        }, ([$isVisible]: [boolean]) => {
        readonly hidden: true | undefined;
        readonly tabindex: -1;
        readonly style: string;
        readonly 'aria-hidden': true;
        readonly 'data-state': "open" | "closed";
        }, string>;
        close: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<DialogEvents['close']>, () => {
        readonly type: "button";
        }, string>;
        portalled: ExplicitBuilderReturn<Writable<string | HTMLElement | null>, <Node_2 extends any>(node: HTMLElement) => {
        destroy(): void;
        }, ($portal: string | HTMLElement | null) => {
        'data-portal': string | undefined;
        }, string>;
    };
    states: {
        open: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
    };
    options: {
        preventScroll: Writable<boolean>;
        closeOnEscape: Writable<boolean>;
        closeOnOutsideClick: Writable<boolean>;
        role: Writable<"dialog" | "alertdialog">;
        defaultOpen: Writable<boolean>;
        open?: Writable<Writable<boolean> | undefined> | undefined;
        onOpenChange?: Writable<ChangeFn<boolean> | undefined> | undefined;
        portal: Writable<string | HTMLElement | null>;
        forceVisible: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreateDialogProps = {
    preventScroll?: boolean;
    closeOnEscape?: boolean;
    closeOnOutsideClick?: boolean;
    role?: 'dialog' | 'alertdialog';
    defaultOpen?: boolean;
    open?: Writable<boolean>;
    onOpenChange?: ChangeFn<boolean>;
    portal?: HTMLElement | string | null;
    forceVisible?: boolean;
};

// @public (undocumented)
export function createDropdownMenu(props?: CreateDropdownMenuProps): {
    elements: {
        trigger: ExplicitBuilderReturn<[Writable<boolean>], (node: HTMLElement) => MeltActionReturn<"keydown" | "pointerdown">, ([$rootOpen]: [boolean]) => {
        readonly 'aria-controls': string;
        readonly 'aria-expanded': boolean;
        readonly 'data-state': "open" | "closed";
        readonly id: string;
        readonly tabindex: 0;
        }, string>;
        menu: ExplicitBuilderReturn<[Readable<boolean>, Writable<string | HTMLElement | null | undefined>], (node: HTMLElement) => MeltActionReturn<"keydown">, ([$isVisible, $portal]: [boolean, string | HTMLElement | null | undefined]) => {
        readonly role: "menu";
        readonly hidden: true | undefined;
        readonly style: string;
        readonly id: string;
        readonly 'aria-labelledby': string;
        readonly 'data-state': "open" | "closed";
        readonly 'data-portal': "" | undefined;
        readonly tabindex: -1;
        }, string>;
        item: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerdown" | "pointerleave" | "pointermove">, () => {
        role: string;
        tabindex: number;
        'data-orientation': string;
        }, string>;
        arrow: ExplicitBuilderReturn<Writable<number | undefined>, Action<any, any, Record<never, any>>, ($arrowSize: number | undefined) => {
        'data-arrow': boolean;
        style: string;
        }, string>;
        separator: ExplicitBuilderReturn<[Writable<Orientation>, Writable<boolean>], Action<any, any, Record<never, any>>, ([$orientation, $decorative]: [Orientation, boolean]) => {
        role: string;
        'aria-orientation': "vertical" | undefined;
        'aria-hidden': boolean;
        'data-orientation': Orientation;
        }, "separator">;
        group: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => (groupId: string) => {
        role: string;
        'aria-labelledby': string;
        }, string>;
        groupLabel: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => (groupId: string) => {
        id: string;
        }, string>;
    };
    states: {
        open: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
    };
    builders: {
        createCheckboxItem: (props?: _CheckboxItemProps | undefined) => {
            elements: {
                checkboxItem: ExplicitBuilderReturn<[{
                update: (updater: Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
                set: (this: void, value: boolean | "indeterminate") => void;
                subscribe(this: void, run: Subscriber<boolean | "indeterminate">, invalidate?: Invalidator<boolean | "indeterminate"> | undefined): Unsubscriber;
                }, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerdown" | "pointerleave" | "pointermove">, ([$checked, $disabled]: [boolean | "indeterminate", boolean]) => {
                readonly role: "menuitemcheckbox";
                readonly tabindex: -1;
                readonly 'data-orientation': "vertical";
                readonly 'aria-checked': "true" | "mixed" | "false";
                readonly 'data-disabled': true | undefined;
                readonly 'data-state': "indeterminate" | "checked" | "unchecked";
                }, string>;
            };
            states: {
                checked: {
                    update: (updater: Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
                    set: (this: void, value: boolean | "indeterminate") => void;
                    subscribe(this: void, run: Subscriber<boolean | "indeterminate">, invalidate?: Invalidator<boolean | "indeterminate"> | undefined): Unsubscriber;
                };
            };
            options: {
                disabled: Writable<boolean>;
            };
        };
        createSubmenu: (args?: _CreateSubmenuProps | undefined) => {
            ids: {
                menu: string;
                trigger: string;
            };
            elements: {
                subTrigger: ExplicitBuilderReturn<[Writable<boolean>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerleave" | "pointermove">, ([$subOpen, $disabled]: [boolean, boolean]) => {
                readonly role: "menuitem";
                readonly id: string;
                readonly tabindex: -1;
                readonly 'aria-controls': string;
                readonly 'aria-expanded': boolean;
                readonly 'data-state': "open" | "closed";
                readonly 'data-disabled': true | undefined;
                readonly 'aria-haspopop': "menu";
                }, string>;
                subMenu: ExplicitBuilderReturn<[Readable<boolean>], (node: HTMLElement) => MeltActionReturn<"focusout" | "keydown" | "pointermove">, ([$subIsVisible]: [boolean]) => {
                readonly role: "menu";
                readonly hidden: true | undefined;
                readonly style: string;
                readonly id: string;
                readonly 'aria-labelledby': string;
                readonly 'data-state': "open" | "closed";
                readonly tabindex: -1;
                }, string>;
                subArrow: ExplicitBuilderReturn<Writable<number>, Action<any, any, Record<never, any>>, ($arrowSize: number) => {
                'data-arrow': boolean;
                style: string;
                }, string>;
            };
            states: {
                subOpen: Writable<boolean>;
            };
            options: {
                positioning: Writable<FloatingConfig | {
                placement: "right-start";
                gutter: number;
                }>;
                arrowSize: Writable<number>;
                disabled: Writable<boolean>;
                preventScroll: Writable<true>;
                closeOnEscape: Writable<true>;
                closeOnOutsideClick: Writable<true>;
                portal: Writable<string>;
                loop: Writable<false>;
                dir: Writable<"ltr">;
                defaultOpen: Writable<false>;
                typeahead: Writable<true>;
            };
        };
        createMenuRadioGroup: (args?: _CreateRadioGroupProps) => {
            elements: {
                radioGroup: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => {
                role: string;
                }, string>;
                radioItem: ExplicitBuilderReturn<[{
                update: (updater: Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
                set: (this: void, value: string | null) => void;
                subscribe(this: void, run: Subscriber<string | null>, invalidate?: Invalidator<string | null> | undefined): Unsubscriber;
                }], (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerdown" | "pointerleave" | "pointermove">, ([$value]: [string | null]) => (itemProps: _RadioItemProps) => {
                disabled: boolean;
                role: string;
                'data-state': string;
                'aria-checked': boolean;
                'data-disabled': boolean | undefined;
                'data-value': string;
                'data-orientation': string;
                tabindex: number;
                }, string>;
            };
            states: {
                value: {
                    update: (updater: Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
                    set: (this: void, value: string | null) => void;
                    subscribe(this: void, run: Subscriber<string | null>, invalidate?: Invalidator<string | null> | undefined): Unsubscriber;
                };
            };
            helpers: {
                isChecked: Readable<(itemValue: string) => boolean>;
            };
        };
    };
    options: {
        positioning: Writable<FloatingConfig | {
        placement: "bottom";
        }>;
        arrowSize: Writable<number>;
        dir: Writable<TextDirection>;
        preventScroll: Writable<boolean>;
        closeOnEscape: Writable<boolean>;
        portal: Writable<string | HTMLElement | null | undefined>;
        closeOnOutsideClick: Writable<boolean>;
        loop: Writable<boolean>;
        defaultOpen: Writable<boolean>;
        open?: Writable<Writable<boolean> | undefined> | undefined;
        onOpenChange?: Writable<ChangeFn<boolean> | undefined> | undefined;
        forceVisible: Writable<boolean>;
        typeahead: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreateDropdownMenuCheckboxItemProps = _Menu['checkboxItem'];

// @public (undocumented)
export type CreateDropdownMenuProps = _Menu['builder'];

// @public (undocumented)
export type CreateDropdownMenuRadioGroupProps = _Menu['radioGroup'];

// @public (undocumented)
export type CreateDropdownSubmenuProps = _Menu['submenu'];

// @public (undocumented)
export function createLabel(): {
    elements: {
        root: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<LabelEvents['root']>, (() => Record<string, any> | ((...args: any[]) => Record<string, any>)) | ((values: any) => Record<string, any> | ((...args: any[]) => Record<string, any>)) | ((values: any[]) => Record<string, any> | ((...args: any[]) => Record<string, any>)) | ((values: [any, ...any[]]) => Record<string, any> | ((...args: any[]) => Record<string, any>)), "label">;
    };
};

// @public (undocumented)
export function createLinkPreview(props?: CreateLinkPreviewProps): {
    ids: {
        content: string;
        trigger: string;
    };
    elements: {
        trigger: ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }], (node: HTMLElement) => MeltActionReturn<LinkPreviewEvents['trigger']>, ([$open]: [boolean]) => {
        role: "button";
        'aria-haspopup': "dialog";
        'aria-expanded': boolean;
        'data-state': string;
        'aria-controls': string;
        id: string;
        }, string>;
        content: ExplicitBuilderReturn<[Readable<boolean>, Writable<string | HTMLElement | null>], (node: HTMLElement) => MeltActionReturn<LinkPreviewEvents['content']>, ([$isVisible, $portal]: [boolean, string | HTMLElement | null]) => {
        hidden: boolean | undefined;
        tabindex: number;
        style: string;
        id: string;
        'data-state': string;
        'data-portal': string | undefined;
        }, string>;
        arrow: ExplicitBuilderReturn<Writable<number>, Action<any, any, Record<never, any>>, ($arrowSize: number) => {
        'data-arrow': boolean;
        style: string;
        }, string>;
    };
    states: {
        open: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
    };
    options: {
        positioning: Writable<FloatingConfig | {
        placement: "bottom";
        }>;
        defaultOpen: Writable<boolean>;
        open?: Writable<Writable<boolean> | undefined> | undefined;
        onOpenChange?: Writable<ChangeFn<boolean> | undefined> | undefined;
        openDelay: Writable<number>;
        closeDelay: Writable<number>;
        closeOnOutsideClick: Writable<boolean>;
        closeOnEscape: Writable<boolean>;
        arrowSize: Writable<number>;
        forceVisible: Writable<boolean>;
        portal: Writable<string | HTMLElement | null>;
    };
};

// @public (undocumented)
export type CreateLinkPreviewProps = {
    positioning?: FloatingConfig;
    defaultOpen?: boolean;
    open?: Writable<boolean>;
    onOpenChange?: ChangeFn<boolean>;
    openDelay?: number;
    closeDelay?: number;
    closeOnOutsideClick?: boolean;
    closeOnEscape?: boolean;
    arrowSize?: number;
    forceVisible?: boolean;
    portal?: HTMLElement | string | null;
};

// @public (undocumented)
export function createMenubar(props?: CreateMenubarProps): {
    ids: {
        menubar: string;
    };
    elements: {
        menubar: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => {
        destroy?: undefined;
        } | {
        destroy: typeof noop;
        }, () => {
        role: string;
        'data-melt-menubar': string;
        'data-orientation': string;
        id: string;
        }, string>;
    };
    builders: {
        createMenu: (props?: CreateMenubarMenuProps) => {
            ids: {
                menubar: string;
            };
            elements: {
                menu: ExplicitBuilderReturn<[Readable<boolean>, Writable<string | HTMLElement | null | undefined>], (node: HTMLElement) => MeltActionReturn<MenubarEvents['menu']>, ([$isVisible, $portal]: [boolean, string | HTMLElement | null | undefined]) => {
                readonly role: "menu";
                readonly hidden: true | undefined;
                readonly style: string;
                readonly id: string;
                readonly 'aria-labelledby': string;
                readonly 'data-state': "open" | "closed";
                readonly 'data-melt-scope': string;
                readonly 'data-portal': "" | undefined;
                readonly tabindex: -1;
                }, string>;
                trigger: ExplicitBuilderReturn<[Writable<boolean>], (node: HTMLElement) => MeltActionReturn<MenubarEvents['trigger']>, ([$rootOpen]: [boolean]) => {
                readonly 'aria-controls': string;
                readonly 'aria-expanded': boolean;
                readonly 'data-state': "open" | "closed";
                readonly id: string;
                readonly 'aria-haspopup': "menu";
                readonly 'data-orientation': "horizontal";
                readonly role: "menuitem";
                }, string>;
                item: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerdown" | "pointerleave" | "pointermove">, () => {
                role: string;
                tabindex: number;
                'data-orientation': string;
                }, string>;
                arrow: ExplicitBuilderReturn<Writable<number | undefined>, Action<any, any, Record<never, any>>, ($arrowSize: number | undefined) => {
                'data-arrow': boolean;
                style: string;
                }, string>;
                separator: ExplicitBuilderReturn<[Writable<Orientation>, Writable<boolean>], Action<any, any, Record<never, any>>, ([$orientation, $decorative]: [Orientation, boolean]) => {
                role: string;
                'aria-orientation': "vertical" | undefined;
                'aria-hidden': boolean;
                'data-orientation': Orientation;
                }, "separator">;
                group: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => (groupId: string) => {
                role: string;
                'aria-labelledby': string;
                }, string>;
                groupLabel: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => (groupId: string) => {
                id: string;
                }, string>;
            };
            builders: {
                createCheckboxItem: (props?: _CheckboxItemProps | undefined) => {
                    elements: {
                        checkboxItem: ExplicitBuilderReturn<[{
                        update: (updater: Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
                        set: (this: void, value: boolean | "indeterminate") => void;
                        subscribe(this: void, run: Subscriber<boolean | "indeterminate">, invalidate?: Invalidator<boolean | "indeterminate"> | undefined): Unsubscriber;
                        }, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerdown" | "pointerleave" | "pointermove">, ([$checked, $disabled]: [boolean | "indeterminate", boolean]) => {
                        readonly role: "menuitemcheckbox";
                        readonly tabindex: -1;
                        readonly 'data-orientation': "vertical";
                        readonly 'aria-checked': "true" | "mixed" | "false";
                        readonly 'data-disabled': true | undefined;
                        readonly 'data-state': "indeterminate" | "checked" | "unchecked";
                        }, string>;
                    };
                    states: {
                        checked: {
                            update: (updater: Updater<boolean | "indeterminate">, sideEffect?: ((newValue: boolean | "indeterminate") => void) | undefined) => void;
                            set: (this: void, value: boolean | "indeterminate") => void;
                            subscribe(this: void, run: Subscriber<boolean | "indeterminate">, invalidate?: Invalidator<boolean | "indeterminate"> | undefined): Unsubscriber;
                        };
                    };
                    options: {
                        disabled: Writable<boolean>;
                    };
                };
                createSubmenu: (args?: _CreateSubmenuProps | undefined) => {
                    ids: {
                        menu: string;
                        trigger: string;
                    };
                    elements: {
                        subTrigger: ExplicitBuilderReturn<[Writable<boolean>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerleave" | "pointermove">, ([$subOpen, $disabled]: [boolean, boolean]) => {
                        readonly role: "menuitem";
                        readonly id: string;
                        readonly tabindex: -1;
                        readonly 'aria-controls': string;
                        readonly 'aria-expanded': boolean;
                        readonly 'data-state': "open" | "closed";
                        readonly 'data-disabled': true | undefined;
                        readonly 'aria-haspopop': "menu";
                        }, string>;
                        subMenu: ExplicitBuilderReturn<[Readable<boolean>], (node: HTMLElement) => MeltActionReturn<"focusout" | "keydown" | "pointermove">, ([$subIsVisible]: [boolean]) => {
                        readonly role: "menu";
                        readonly hidden: true | undefined;
                        readonly style: string;
                        readonly id: string;
                        readonly 'aria-labelledby': string;
                        readonly 'data-state': "open" | "closed";
                        readonly tabindex: -1;
                        }, string>;
                        subArrow: ExplicitBuilderReturn<Writable<number>, Action<any, any, Record<never, any>>, ($arrowSize: number) => {
                        'data-arrow': boolean;
                        style: string;
                        }, string>;
                    };
                    states: {
                        subOpen: Writable<boolean>;
                    };
                    options: {
                        positioning: Writable<FloatingConfig | {
                        placement: "right-start";
                        gutter: number;
                        }>;
                        arrowSize: Writable<number>;
                        disabled: Writable<boolean>;
                        preventScroll: Writable<true>;
                        closeOnEscape: Writable<true>;
                        closeOnOutsideClick: Writable<true>;
                        portal: Writable<string>;
                        loop: Writable<false>;
                        dir: Writable<"ltr">;
                        defaultOpen: Writable<false>;
                        typeahead: Writable<true>;
                    };
                };
                createMenuRadioGroup: (args?: _CreateRadioGroupProps) => {
                    elements: {
                        radioGroup: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => {
                        role: string;
                        }, string>;
                        radioItem: ExplicitBuilderReturn<[{
                        update: (updater: Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
                        set: (this: void, value: string | null) => void;
                        subscribe(this: void, run: Subscriber<string | null>, invalidate?: Invalidator<string | null> | undefined): Unsubscriber;
                        }], (node: HTMLElement) => MeltActionReturn<"click" | "focusin" | "focusout" | "keydown" | "pointerdown" | "pointerleave" | "pointermove">, ([$value]: [string | null]) => (itemProps: _RadioItemProps) => {
                        disabled: boolean;
                        role: string;
                        'data-state': string;
                        'aria-checked': boolean;
                        'data-disabled': boolean | undefined;
                        'data-value': string;
                        'data-orientation': string;
                        tabindex: number;
                        }, string>;
                    };
                    states: {
                        value: {
                            update: (updater: Updater<string | null>, sideEffect?: ((newValue: string | null) => void) | undefined) => void;
                            set: (this: void, value: string | null) => void;
                            subscribe(this: void, run: Subscriber<string | null>, invalidate?: Invalidator<string | null> | undefined): Unsubscriber;
                        };
                    };
                    helpers: {
                        isChecked: Readable<(itemValue: string) => boolean>;
                    };
                };
            };
            states: {
                open: Writable<boolean>;
            };
            options: {
                positioning: Writable<FloatingConfig | {
                placement: "bottom-start";
                }>;
                arrowSize: Writable<number>;
                dir: Writable<TextDirection>;
                preventScroll: Writable<boolean>;
                closeOnEscape: Writable<boolean>;
                portal: Writable<string | HTMLElement | null | undefined>;
                closeOnOutsideClick: Writable<boolean>;
                loop: Writable<boolean>;
                defaultOpen: Writable<boolean>;
                open?: Writable<Writable<boolean> | undefined> | undefined;
                onOpenChange?: Writable<ChangeFn<boolean> | undefined> | undefined;
                forceVisible: Writable<boolean>;
                typeahead: Writable<boolean>;
            };
        };
    };
    options: {
        loop: Writable<boolean>;
        closeOnEscape: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreateMenubarMenuProps = _Menu['builder'];

// @public (undocumented)
export type CreateMenubarProps = {
    loop?: boolean;
    closeOnEscape?: boolean;
};

// @public (undocumented)
export type CreateMenubarSubmenuProps = _Menu['submenu'];

// @public (undocumented)
export type CreateMenuCheckboxItemProps = _Menu['checkboxItem'];

// @public (undocumented)
export type CreateMenuRadioGroupProps = _Menu['radioGroup'];

// @public (undocumented)
export function createPagination(props: CreatePaginationProps): {
    elements: {
        root: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => {
        'data-scope': string;
        }, string>;
        pageTrigger: ExplicitBuilderReturn<    {
        update: (updater: Updater<number>, sideEffect?: ((newValue: number) => void) | undefined) => void;
        set: (this: void, value: number) => void;
        subscribe(this: void, run: Subscriber<number>, invalidate?: Invalidator<number> | undefined): Unsubscriber;
        }, (node: HTMLElement) => MeltActionReturn<PaginationEvents['pageTrigger']>, ($page: number) => (pageItem: Page) => {
        'aria-label': string;
        'data-value': number;
        'data-selected': string | undefined;
        }, string>;
        prevButton: ExplicitBuilderReturn<    {
        update: (updater: Updater<number>, sideEffect?: ((newValue: number) => void) | undefined) => void;
        set: (this: void, value: number) => void;
        subscribe(this: void, run: Subscriber<number>, invalidate?: Invalidator<number> | undefined): Unsubscriber;
        }, (node: HTMLElement) => MeltActionReturn<PaginationEvents['prevButton']>, ($page: number) => {
        readonly 'aria-label': "Previous";
        readonly disabled: boolean;
        }, string>;
        nextButton: ExplicitBuilderReturn<[{
        update: (updater: Updater<number>, sideEffect?: ((newValue: number) => void) | undefined) => void;
        set: (this: void, value: number) => void;
        subscribe(this: void, run: Subscriber<number>, invalidate?: Invalidator<number> | undefined): Unsubscriber;
        }, Readable<number>], (node: HTMLElement) => MeltActionReturn<PaginationEvents['nextButton']>, ([$page, $totalPages]: [number, number]) => {
        readonly 'aria-label': "Next";
        readonly disabled: boolean;
        }, string>;
    };
    states: {
        range: Readable<    {
        start: number;
        end: number;
        }>;
        page: {
            update: (updater: Updater<number>, sideEffect?: ((newValue: number) => void) | undefined) => void;
            set: (this: void, value: number) => void;
            subscribe(this: void, run: Subscriber<number>, invalidate?: Invalidator<number> | undefined): Unsubscriber;
        };
        pages: Readable<PageItem[]>;
        totalPages: Readable<number>;
    };
    options: {
        count: Writable<number>;
        perPage: Writable<number>;
        siblingCount: Writable<number>;
    };
};

// @public (undocumented)
export type CreatePaginationProps = {
    count: number;
    perPage?: number;
    siblingCount?: number;
    defaultPage?: number;
    page?: Writable<number>;
    onPageChange?: ChangeFn<number>;
};

// @public (undocumented)
export function createPinInput(props?: CreatePinInputProps): {
    ids: {
        root: string;
    };
    elements: {
        root: ExplicitBuilderReturn<    {
        update: (updater: Updater<string[]>, sideEffect?: ((newValue: string[]) => void) | undefined) => void;
        set: (this: void, value: string[]) => void;
        subscribe(this: void, run: Subscriber<string[]>, invalidate?: Invalidator<string[]> | undefined): Unsubscriber;
        }, Action<any, any, Record<never, any>>, ($value: string[]) => {
        id: string;
        'data-complete': string | undefined;
        }, string>;
        input: ExplicitBuilderReturn<[{
        update: (updater: Updater<string[]>, sideEffect?: ((newValue: string[]) => void) | undefined) => void;
        set: (this: void, value: string[]) => void;
        subscribe(this: void, run: Subscriber<string[]>, invalidate?: Invalidator<string[]> | undefined): Unsubscriber;
        }, Writable<string>, Writable<boolean>, Writable<"text" | "password">], (node: HTMLInputElement) => MeltActionReturn<PinInputEvents['input']>, ([$value, $placeholder, $disabled, $type]: [string[], string, boolean, "text" | "password"]) => () => {
        'data-complete': string | undefined;
        placeholder: string;
        disabled: boolean | undefined;
        type: "text" | "password";
        value: string;
        }, string>;
        hiddenInput: ExplicitBuilderReturn<[Readable<string>, Writable<string | undefined>], Action<any, any, Record<never, any>>, ([$valueStr, $nameStore]: [string, string | undefined]) => {
        value: string;
        name: string | undefined;
        type: string;
        'aria-hidden': boolean;
        hidden: boolean;
        tabIndex: number;
        style: string;
        }, string>;
    };
    states: {
        value: {
            update: (updater: Updater<string[]>, sideEffect?: ((newValue: string[]) => void) | undefined) => void;
            set: (this: void, value: string[]) => void;
            subscribe(this: void, run: Subscriber<string[]>, invalidate?: Invalidator<string[]> | undefined): Unsubscriber;
        };
        valueStr: Readable<string>;
    };
    helpers: {
        clear: () => void;
    };
    options: {
        disabled: Writable<boolean>;
        type: Writable<"text" | "password">;
        name: Writable<string | undefined>;
        onValueChange?: Writable<ChangeFn<string[]> | undefined> | undefined;
        defaultValue: Writable<string[]>;
        placeholder: Writable<string>;
    };
};

// @public (undocumented)
export type CreatePinInputProps = {
    placeholder?: string;
    name?: string;
    disabled?: boolean;
    type?: 'text' | 'password';
    defaultValue?: string[];
    value?: Writable<string[]>;
    onValueChange?: ChangeFn<string[]>;
};

// @public (undocumented)
export function createPopover(args?: CreatePopoverProps): {
    ids: {
        content: string;
        trigger: string;
    };
    elements: {
        trigger: ExplicitBuilderReturn<    {
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, (node: HTMLElement) => MeltActionReturn<PopoverEvents['trigger']>, ($open: boolean) => {
        readonly role: "button";
        readonly 'aria-haspopup': "dialog";
        readonly 'aria-expanded': boolean;
        readonly 'data-state': "open" | "closed";
        readonly 'aria-controls': string;
        readonly id: string;
        }, string>;
        content: ExplicitBuilderReturn<[Readable<boolean>, Writable<string | HTMLElement | null | undefined>], <Node_1 extends any>(node: HTMLElement) => {
        destroy(): void;
        }, ([$isVisible, $portal]: [boolean, string | HTMLElement | null | undefined]) => {
        hidden: boolean | undefined;
        tabindex: number;
        style: string;
        id: string;
        'data-state': string;
        'data-portal': string | undefined;
        }, string>;
        arrow: ExplicitBuilderReturn<Writable<number>, Action<any, any, Record<never, any>>, ($arrowSize: number) => {
        'data-arrow': boolean;
        style: string;
        }, string>;
        close: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<PopoverEvents['close']>, () => {
        readonly type: "button";
        }, string>;
    };
    states: {
        open: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
    };
    options: {
        forceVisible: Writable<boolean>;
        defaultOpen: Writable<boolean>;
        onOpenChange: Writable<ChangeFn<boolean> | undefined>;
        preventScroll: Writable<boolean>;
        portal: Writable<string | HTMLElement | null | undefined>;
        positioning: Writable<FloatingConfig | {
        placement: "bottom";
        }>;
        arrowSize: Writable<number>;
        closeOnOutsideClick: Writable<boolean>;
        closeOnEscape: Writable<boolean>;
        disableFocusTrap: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreatePopoverProps = {
    positioning?: FloatingConfig;
    arrowSize?: number;
    defaultOpen?: boolean;
    open?: Writable<boolean>;
    onOpenChange?: ChangeFn<boolean>;
    disableFocusTrap?: boolean;
    closeOnEscape?: boolean;
    closeOnOutsideClick?: boolean;
    preventScroll?: boolean;
    portal?: HTMLElement | string | null;
    forceVisible?: boolean;
};

// @public (undocumented)
export const createProgress: (props?: CreateProgressProps) => {
    elements: {
        root: ExplicitBuilderReturn<[{
        update: (updater: Updater<number>, sideEffect?: ((newValue: number) => void) | undefined) => void;
        set: (this: void, value: number) => void;
        subscribe(this: void, run: Subscriber<number>, invalidate?: Invalidator<number> | undefined): Unsubscriber;
        }, Writable<number>], Action<any, any, Record<never, any>>, ([$value, $max]: [number, number]) => {
        value: number;
        max: number;
        role: string;
        'aria-valuemin': number;
        'aria-valuemax': number;
        'aria-valuenow': number;
        'data-value': number;
        'data-state': string;
        'data-max': number;
        }, string>;
    };
    states: {
        value: {
            update: (updater: Updater<number>, sideEffect?: ((newValue: number) => void) | undefined) => void;
            set: (this: void, value: number) => void;
            subscribe(this: void, run: Subscriber<number>, invalidate?: Invalidator<number> | undefined): Unsubscriber;
        };
    };
    options: {
        onValueChange?: Writable<ChangeFn<number> | undefined> | undefined;
        defaultValue: Writable<number>;
        max: Writable<number>;
    };
};

// @public (undocumented)
export type CreateProgressProps = {
    defaultValue?: number;
    value?: Writable<number>;
    onValueChange?: ChangeFn<number>;
    max?: number;
};

// @public (undocumented)
export function createRadioGroup(props?: CreateRadioGroupProps): {
    elements: {
        root: ExplicitBuilderReturn<[Writable<boolean>, Writable<Orientation>], Action<any, any, Record<never, any>>, ([$required, $orientation]: [boolean, Orientation]) => {
        readonly role: "radiogroup";
        readonly 'aria-required': boolean;
        readonly 'data-orientation': Orientation;
        }, string>;
        item: ExplicitBuilderReturn<[{
        update: (updater: Updater<string>, sideEffect?: ((newValue: string) => void) | undefined) => void;
        set: (this: void, value: string) => void;
        subscribe(this: void, run: Subscriber<string>, invalidate?: Invalidator<string> | undefined): Unsubscriber;
        }, Writable<Orientation>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<RadioGroupEvents['item']>, ([$value, $orientation, $disabled]: [string, Orientation, boolean]) => (props: RadioGroupItemProps) => {
        readonly disabled: boolean;
        readonly 'data-value': string;
        readonly 'data-orientation': Orientation;
        readonly 'data-disabled': true | undefined;
        readonly 'data-state': "checked" | "unchecked";
        readonly 'aria-checked': boolean;
        readonly type: "button";
        readonly role: "radio";
        readonly tabindex: 0 | -1;
        }, string>;
        hiddenInput: ExplicitBuilderReturn<[Writable<boolean>, {
        update: (updater: Updater<string>, sideEffect?: ((newValue: string) => void) | undefined) => void;
        set: (this: void, value: string) => void;
        subscribe(this: void, run: Subscriber<string>, invalidate?: Invalidator<string> | undefined): Unsubscriber;
        }, Writable<boolean>], (_node: HTMLInputElement) => void, ([$disabled, $value, $required]: [boolean, string, boolean]) => {
        disabled: boolean | undefined;
        value: string;
        required: boolean;
        type: string;
        'aria-hidden': boolean;
        hidden: boolean;
        tabIndex: number;
        style: string;
        }, string>;
    };
    states: {
        value: {
            update: (updater: Updater<string>, sideEffect?: ((newValue: string) => void) | undefined) => void;
            set: (this: void, value: string) => void;
            subscribe(this: void, run: Subscriber<string>, invalidate?: Invalidator<string> | undefined): Unsubscriber;
        };
    };
    helpers: {
        isChecked: Readable<(itemValue: string) => boolean>;
    };
    options: {
        disabled: Writable<boolean>;
        onValueChange?: Writable<ChangeFn<string> | undefined> | undefined;
        defaultValue: Writable<string | undefined>;
        required: Writable<boolean>;
        loop: Writable<boolean>;
        orientation: Writable<Orientation>;
    };
};

// @public (undocumented)
export type CreateRadioGroupProps = {
    disabled?: boolean;
    required?: boolean;
    loop?: boolean;
    orientation?: Orientation;
    defaultValue?: string;
    value?: Writable<string>;
    onValueChange?: ChangeFn<string>;
};

// @public (undocumented)
export function createSelect<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>>(props?: CreateSelectProps<Value, Multiple, S>): {
    elements: {
        group: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => (groupId: string) => {
        role: string;
        'aria-labelledby': string;
        }, string>;
        groupLabel: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => (groupId: string) => {
        id: string;
        }, string>;
        trigger: ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, Writable<HTMLElement | null>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<"input" | "click" | "keydown">, ([$open, $highlightedItem, $disabled]: [boolean, HTMLElement | null, boolean]) => {
        readonly 'aria-activedescendant': string | undefined;
        readonly 'aria-autocomplete': "list";
        readonly 'aria-controls': string;
        readonly 'aria-expanded': boolean;
        readonly 'aria-labelledby': string;
        readonly 'data-melt-id': string;
        readonly id: string;
        readonly role: "combobox";
        readonly disabled: true | undefined;
        }, string>;
        option: ExplicitBuilderReturn<[{
        update: (updater: Updater<S | undefined>, sideEffect?: ((newValue: S | undefined) => void) | undefined) => void;
        set: (this: void, value: S | undefined) => void;
        subscribe(this: void, run: Subscriber<S | undefined>, invalidate?: Invalidator<S | undefined> | undefined): Unsubscriber;
        }], (node: HTMLElement) => MeltActionReturn<"click" | "pointermove">, ([$selected]: [S | undefined]) => (props: ListboxOptionProps<unknown>) => {
        readonly 'data-value': string;
        readonly 'data-label': string | undefined;
        readonly 'data-disabled': true | undefined;
        readonly 'aria-disabled': true | undefined;
        readonly 'aria-selected': boolean;
        readonly 'data-selected': "" | undefined;
        readonly id: string;
        readonly role: "option";
        readonly style: string;
        }, string>;
        menu: ExplicitBuilderReturn<[Readable<boolean>], (node: HTMLElement) => MeltActionReturn<"pointerleave">, ([$isVisible]: [boolean]) => {
        readonly hidden: true | undefined;
        readonly id: string;
        readonly role: "listbox";
        readonly style: string;
        }, string>;
        label: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<"mousedown">, () => {
        id: string;
        for: string;
        }, string>;
        hiddenInput: ExplicitBuilderReturn<[{
        update: (updater: Updater<S | undefined>, sideEffect?: ((newValue: S | undefined) => void) | undefined) => void;
        set: (this: void, value: S | undefined) => void;
        subscribe(this: void, run: Subscriber<S | undefined>, invalidate?: Invalidator<S | undefined> | undefined): Unsubscriber;
        }, Writable<boolean>, Writable<string | undefined>], Action<any, any, Record<never, any>>, ([$selected, $required, $name]: [S | undefined, boolean, string | undefined]) => {
        required: boolean | undefined;
        value: unknown;
        name: string | undefined;
        type: string;
        'aria-hidden': boolean;
        hidden: boolean;
        tabIndex: number;
        style: string;
        }, string>;
        arrow: ExplicitBuilderReturn<Writable<number | undefined>, Action<any, any, Record<never, any>>, ($arrowSize: number | undefined) => {
        'data-arrow': boolean;
        style: string;
        }, string>;
    };
    states: {
        selectedLabel: Readable<string>;
        open: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
        selected: {
            update: (updater: Updater<S | undefined>, sideEffect?: ((newValue: S | undefined) => void) | undefined) => void;
            set: (this: void, value: S | undefined) => void;
            subscribe(this: void, run: Subscriber<S | undefined>, invalidate?: Invalidator<S | undefined> | undefined): Unsubscriber;
        };
        highlighted: Readable<ListboxOption<unknown> | undefined>;
    };
    ids: {
        trigger: string;
        menu: string;
        label: string;
    };
    helpers: {
        isSelected: Readable<(value: unknown) => boolean>;
        isHighlighted: Readable<(item: unknown) => boolean>;
        closeMenu: () => void;
    };
    options: {
        multiple: Writable<Multiple>;
        disabled: Writable<boolean>;
        forceVisible: Writable<boolean>;
        name: Writable<string | undefined>;
        required: Writable<boolean>;
        onOpenChange?: Writable<ChangeFn<boolean> | undefined> | undefined;
        preventScroll: Writable<boolean>;
        portal: Writable<string | HTMLElement | null | undefined>;
        positioning: Writable<FloatingConfig | {
        placement: "bottom";
        sameWidth: true;
        }>;
        arrowSize?: Writable<number | undefined> | undefined;
        scrollAlignment: Writable<"center" | "nearest">;
        loop: Writable<boolean>;
        defaultSelected?: Writable<S | undefined> | undefined;
        selected?: Writable<Writable<S> | undefined> | undefined;
        onSelectedChange?: Writable<ChangeFn<S | undefined> | undefined> | undefined;
        closeOnOutsideClick: Writable<boolean>;
        closeOnEscape: Writable<boolean>;
        typeahead: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreateSelectProps<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = Omit<CreateListboxProps<Value, Multiple, S>, 'builder'>;

// @public (undocumented)
export const createSeparator: (props?: CreateSeparatorProps) => {
    elements: {
        root: ExplicitBuilderReturn<[Writable<Orientation>, Writable<boolean>], Action<any, any, Record<never, any>>, ([$orientation, $decorative]: [Orientation, boolean]) => {
        role: string;
        'aria-orientation': "vertical" | undefined;
        'aria-hidden': boolean;
        'data-orientation': Orientation;
        }, "separator">;
    };
    options: {
        orientation: Writable<Orientation>;
        decorative: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreateSeparatorProps = {
    orientation?: Orientation;
    decorative?: boolean;
};

// @public (undocumented)
export const createSlider: (props?: CreateSliderProps) => {
    ids: {
        root: string;
    };
    elements: {
        root: ExplicitBuilderReturn<[Writable<boolean>, Writable<"horizontal" | "vertical">], Action<any, any, Record<never, any>>, ([$disabled, $orientation]: [boolean, "horizontal" | "vertical"]) => {
        disabled: boolean | undefined;
        'aria-disabled': string | undefined;
        'data-orientation': "horizontal" | "vertical";
        style: string | undefined;
        'data-melt-id': string;
        }, string>;
        thumb: ExplicitBuilderReturn<[{
        update: (updater: Updater<number[]>, sideEffect?: ((newValue: number[]) => void) | undefined) => void;
        set: (this: void, value: number[]) => void;
        subscribe(this: void, run: Subscriber<number[]>, invalidate?: Invalidator<number[]> | undefined): Unsubscriber;
        }, Readable<(val: number) => number>, Writable<number>, Writable<number>, Writable<boolean>, Writable<"horizontal" | "vertical">], (node: HTMLElement) => MeltActionReturn<SliderEvents['thumb']>, ([$value, $position, $min, $max, $disabled, $orientation]: [number[], (val: number) => number, number, number, boolean, "horizontal" | "vertical"]) => () => {
        readonly role: "slider";
        readonly 'aria-valuemin': number;
        readonly 'aria-valuemax': number;
        readonly 'aria-valuenow': number;
        readonly 'data-melt-part': "thumb";
        readonly style: string;
        readonly tabindex: 0 | -1;
        }, string>;
        range: ExplicitBuilderReturn<[{
        update: (updater: Updater<number[]>, sideEffect?: ((newValue: number[]) => void) | undefined) => void;
        set: (this: void, value: number[]) => void;
        subscribe(this: void, run: Subscriber<number[]>, invalidate?: Invalidator<number[]> | undefined): Unsubscriber;
        }, Writable<"horizontal" | "vertical">, Readable<(val: number) => number>], Action<any, any, Record<never, any>>, ([$value, $orientation, $position]: [number[], "horizontal" | "vertical", (val: number) => number]) => {
        style: string;
        }, string>;
        tick: ExplicitBuilderReturn<[Readable<number>, {
        update: (updater: Updater<number[]>, sideEffect?: ((newValue: number[]) => void) | undefined) => void;
        set: (this: void, value: number[]) => void;
        subscribe(this: void, run: Subscriber<number[]>, invalidate?: Invalidator<number[]> | undefined): Unsubscriber;
        }, Writable<number>, Writable<number>, Writable<number>, Writable<"horizontal" | "vertical">], Action<any, any, Record<never, any>>, ([$ticks, $value, $min, $max, $step, $orientation]: [number, number[], number, number, number, "horizontal" | "vertical"]) => () => {
        'data-bounded': boolean | undefined;
        style: string;
        }, string>;
    };
    states: {
        value: {
            update: (updater: Updater<number[]>, sideEffect?: ((newValue: number[]) => void) | undefined) => void;
            set: (this: void, value: number[]) => void;
            subscribe(this: void, run: Subscriber<number[]>, invalidate?: Invalidator<number[]> | undefined): Unsubscriber;
        };
        ticks: Readable<number>;
    };
    options: {
        disabled: Writable<boolean>;
        orientation: Writable<"horizontal" | "vertical">;
        max: Writable<number>;
        min: Writable<number>;
        step: Writable<number>;
    };
};

// @public (undocumented)
export type CreateSliderProps = {
    defaultValue?: number[];
    value?: Writable<number[]>;
    onValueChange?: ChangeFn<number[]>;
    min?: number;
    max?: number;
    step?: number;
    orientation?: 'horizontal' | 'vertical';
    disabled?: boolean;
};

// @public (undocumented)
export function createSwitch(props?: CreateSwitchProps): {
    elements: {
        root: ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, Writable<boolean>, Writable<boolean>], <Node_1 extends any>(node: HTMLElement) => MeltActionReturn<SwitchEvents['root']>, ([$checked, $disabled, $required]: [boolean, boolean, boolean]) => {
        readonly 'data-disabled': true | undefined;
        readonly disabled: true | undefined;
        readonly 'data-state': "checked" | "unchecked";
        readonly type: "button";
        readonly role: "switch";
        readonly 'aria-checked': boolean;
        readonly 'aria-required': boolean;
        }, string>;
        input: ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, Writable<string>, Writable<boolean>, Writable<boolean>, Writable<string>], Action<any, any, Record<never, any>>, ([$checked, $name, $required, $disabled, $value]: [boolean, string, boolean, boolean, string]) => {
        readonly type: "checkbox";
        readonly 'aria-hidden': true;
        readonly hidden: true;
        readonly tabindex: -1;
        readonly name: string;
        readonly value: string;
        readonly checked: boolean;
        readonly required: boolean;
        readonly disabled: true | undefined;
        readonly style: string;
        }, string>;
    };
    states: {
        checked: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
    };
    options: {
        disabled: Writable<boolean>;
        value: Writable<string>;
        name: Writable<string>;
        required: Writable<boolean>;
        defaultChecked: Writable<boolean>;
        onCheckedChange?: Writable<ChangeFn<boolean> | undefined> | undefined;
    };
};

// @public (undocumented)
export type CreateSwitchProps = {
    defaultChecked?: boolean;
    checked?: Writable<boolean>;
    onCheckedChange?: ChangeFn<boolean>;
    disabled?: boolean;
    required?: boolean;
    name?: string;
    value?: string;
};

// @public (undocumented)
export function createTableOfContents(args: CreateTableOfContentsArgs): {
    elements: {
        item: ExplicitBuilderReturn<Writable<number[]>, (node: HTMLAnchorElement) => {
        destroy: () => void;
        }, ($activeHeadingIdxs: number[]) => (id: string) => {
        'data-id': string;
        'data-active': string | undefined;
        }, string>;
    };
    states: {
        activeHeadingIdxs: Writable<number[]>;
        headingsTree: Writable<TableOfContentsItem[]>;
    };
};

// @public
export type CreateTableOfContentsArgs = {
    selector: string;
    exclude?: Heading[];
    scrollOffset?: number;
    scrollBehaviour?: ScrollBehaviour;
    activeType?: ActiveType;
    headingFilterFn?: HeadingFilterFn;
    scrollFn?: ScrollFn;
};

// @public (undocumented)
export function createTabs(props?: CreateTabsProps): {
    elements: {
        root: ExplicitBuilderReturn<Writable<Orientation>, Action<any, any, Record<never, any>>, ($orientation: Orientation) => {
        'data-orientation': Orientation;
        }, string>;
        list: ExplicitBuilderReturn<Writable<Orientation>, Action<any, any, Record<never, any>>, ($orientation: Orientation) => {
        role: string;
        'aria-orientation': Orientation;
        'data-orientation': Orientation;
        }, string>;
        trigger: ExplicitBuilderReturn<[{
        update: (updater: Updater<string>, sideEffect?: ((newValue: string) => void) | undefined) => void;
        set: (this: void, value: string) => void;
        subscribe(this: void, run: Subscriber<string>, invalidate?: Invalidator<string> | undefined): Unsubscriber;
        }, Writable<Orientation>], (node: HTMLElement) => MeltActionReturn<TabsEvents['trigger']>, ([$value, $orientation]: [string, Orientation]) => (props: TabsTriggerProps) => {
        type: string;
        role: string;
        'data-state': string;
        tabindex: number;
        'data-value': string;
        'data-orientation': Orientation;
        'data-disabled': boolean | undefined;
        disabled: boolean | undefined;
        }, string>;
        content: ExplicitBuilderReturn<    {
        update: (updater: Updater<string>, sideEffect?: ((newValue: string) => void) | undefined) => void;
        set: (this: void, value: string) => void;
        subscribe(this: void, run: Subscriber<string>, invalidate?: Invalidator<string> | undefined): Unsubscriber;
        }, Action<any, any, Record<never, any>>, ($value: string) => (tabValue: string) => {
        role: string;
        'aria-labelledby': string;
        hidden: boolean | undefined;
        tabindex: number;
        }, string>;
    };
    states: {
        value: {
            update: (updater: Updater<string>, sideEffect?: ((newValue: string) => void) | undefined) => void;
            set: (this: void, value: string) => void;
            subscribe(this: void, run: Subscriber<string>, invalidate?: Invalidator<string> | undefined): Unsubscriber;
        };
    };
    options: {
        loop: Writable<boolean>;
        orientation: Writable<Orientation>;
        activateOnFocus: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreateTabsProps = {
    defaultValue?: string;
    value?: Writable<string>;
    onValueChange?: ChangeFn<string>;
    orientation?: Orientation;
    activateOnFocus?: boolean;
    loop?: boolean;
    autoSet?: boolean;
};

// @public (undocumented)
export function createTagsInput(props?: CreateTagsInputProps): {
    ids: {
        root: string;
        input: string;
    };
    elements: {
        root: ExplicitBuilderReturn<Writable<boolean>, (node: HTMLElement) => MeltActionReturn<TagsInputEvents['root']>, ($disabled: boolean) => {
        readonly 'data-melt-id': string;
        readonly 'data-disabled': true | undefined;
        readonly disabled: true | undefined;
        }, string>;
        input: ExplicitBuilderReturn<[Writable<boolean>, Writable<string>], (node: HTMLInputElement) => MeltActionReturn<TagsInputEvents['input']>, ([$disabled, $placeholder]: [boolean, string]) => {
        'data-melt-id': string;
        'data-disabled': boolean | undefined;
        disabled: boolean | undefined;
        placeholder: string;
        }, string>;
        deleteTrigger: ExplicitBuilderReturn<[Writable<Tag | null>, Writable<Tag | null>, Writable<boolean>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<TagsInputEvents['deleteTrigger']>, ([$selected, $editing, $disabled, $editable]: [Tag | null, Tag | null, boolean, boolean]) => (tag: TagProps) => {
        'aria-selected': boolean | undefined;
        'data-tag-id': string;
        'data-tag-value': string;
        'data-selected': string | undefined;
        'data-editing': string | undefined;
        'data-disabled': boolean | undefined;
        disabled: boolean | undefined;
        tabindex: number;
        }, string>;
        edit: ExplicitBuilderReturn<[Writable<Tag | null>, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<TagsInputEvents['edit']>, ([$editing, $editable]: [Tag | null, boolean]) => (tag: Tag) => {
        'aria-hidden': boolean;
        'data-tag-id': string;
        'data-tag-value': string;
        hidden: boolean | undefined;
        contenteditable: boolean | undefined;
        tabindex: number;
        style: string | undefined;
        }, string>;
        tag: ExplicitBuilderReturn<[Writable<Tag | null>, Writable<Tag | null>, Writable<boolean>, Writable<boolean>], (node: HTMLDivElement) => MeltActionReturn<TagsInputEvents['tag']>, ([$selected, $editing, $disabled, $editable]: [Tag | null, Tag | null, boolean, boolean]) => (tag: TagProps) => {
        'aria-hidden': boolean | undefined;
        'aria-selected': boolean | undefined;
        'data-tag-id': string;
        'data-tag-value': string;
        'data-selected': string | undefined;
        'data-editable': string | undefined;
        'data-editing': string | undefined;
        'data-disabled': boolean | undefined;
        disabled: boolean | undefined;
        hidden: boolean | undefined;
        tabindex: number;
        style: string | undefined;
        }, string>;
    };
    states: {
        tags: {
            update: (updater: Updater<Tag[]>, sideEffect?: ((newValue: Tag[]) => void) | undefined) => void;
            set: (this: void, value: Tag[]) => void;
            subscribe(this: void, run: Subscriber<Tag[]>, invalidate?: Invalidator<Tag[]> | undefined): Unsubscriber;
        };
        inputValue: Readable<string>;
        inputInvalid: Readable<boolean>;
        selected: Readable<Tag | null>;
    };
    helpers: {
        isSelected: Readable<(tag: Tag) => boolean>;
        isInputValid: (v: string) => boolean;
        addTag: (v: string) => Promise<boolean>;
        updateTag: (tag: Tag, select?: boolean) => Promise<boolean>;
        removeTag: (t: Tag) => Promise<boolean>;
    };
    options: {
        disabled: Writable<boolean>;
        blur: Writable<Blur>;
        trim: Writable<boolean>;
        update: Writable<UpdateTag | undefined>;
        selected?: Writable<Tag | undefined> | undefined;
        placeholder: Writable<string>;
        add: Writable<AddTag | undefined>;
        editable: Writable<boolean>;
        defaultTags: Writable<string[] | Tag[]>;
        onTagsChange?: Writable<ChangeFn<Tag[]> | undefined> | undefined;
        unique: Writable<boolean>;
        addOnPaste: Writable<boolean>;
        maxTags: Writable<number | undefined>;
        allowed: Writable<string[]>;
        denied: Writable<string[]>;
        remove: Writable<RemoveTag | undefined>;
    };
};

// @public (undocumented)
export type CreateTagsInputProps = {
    placeholder?: string;
    disabled?: boolean;
    editable?: boolean;
    selected?: Tag;
    defaultTags?: string[] | Tag[];
    tags?: Writable<Tag[]>;
    onTagsChange?: ChangeFn<Tag[]>;
    unique?: boolean;
    trim?: boolean;
    blur?: Blur;
    addOnPaste?: boolean;
    maxTags?: number;
    allowed?: string[];
    denied?: string[];
    add?: AddTag;
    remove?: RemoveTag;
    update?: UpdateTag;
};

// @public (undocumented)
export function createToaster<T = object>(props?: CreateToasterProps): {
    elements: {
        content: ExplicitBuilderReturn<Writable<Map<string, Toast<T>>>, (node: HTMLElement) => MeltActionReturn<ToastEvents['content']>, ($toasts: Map<string, Toast<T>>) => (id: string) => {
        id: string;
        role: string;
        'aria-describedby': string;
        'aria-labelledby': string;
        'aria-live': string;
        tabindex: number;
        } | null, string>;
        title: ExplicitBuilderReturn<Writable<Map<string, Toast<T>>>, Action<any, any, Record<never, any>>, ($toasts: Map<string, Toast<T>>) => (id: string) => {
        id: string;
        } | null, string>;
        description: ExplicitBuilderReturn<Writable<Map<string, Toast<T>>>, Action<any, any, Record<never, any>>, ($toasts: Map<string, Toast<T>>) => (id: string) => {
        id: string;
        } | null, string>;
        close: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<ToastEvents['close']>, () => (id: string) => {
        type: string;
        'data-id': string;
        }, string>;
    };
    states: {
        toasts: Readable<Toast<T>[]>;
    };
    helpers: {
        addToast: (props: AddToastProps<T>) => Toast<T>;
        removeToast: (id: string) => void;
        updateToast: (id: string, data: T) => void;
    };
    actions: {
        portal: Action<HTMLElement, PortalConfig, Record<never, any>>;
    };
    options: {
        closeDelay: Writable<number>;
        type: Writable<"background" | "foreground">;
    };
};

// @public (undocumented)
export type CreateToasterProps = {
    closeDelay?: number;
    type?: 'foreground' | 'background';
};

// @public (undocumented)
export function createToggle(props?: CreateToggleProps): {
    elements: {
        root: ExplicitBuilderReturn<[{
        update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
        set: (this: void, value: boolean) => void;
        subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        }, Writable<boolean>], (node: HTMLElement) => MeltActionReturn<ToggleEvents['root']>, ([$pressed, $disabled]: [boolean, boolean]) => {
        readonly 'data-disabled': true | undefined;
        readonly disabled: true | undefined;
        readonly 'data-state': "on" | "off";
        readonly 'aria-pressed': boolean;
        readonly type: "button";
        }, "toggle">;
    };
    states: {
        pressed: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
    };
    options: {
        disabled: Writable<boolean>;
        defaultPressed: Writable<boolean>;
        onPressedChange?: Writable<ChangeFn<boolean> | undefined> | undefined;
    };
};

// @public (undocumented)
export const createToggleGroup: <T extends ToggleGroupType = "single">(props?: CreateToggleGroupProps<T> | undefined) => {
    elements: {
        root: ExplicitBuilderReturn<Writable<Orientation>, Action<any, any, Record<never, any>>, ($orientation: Orientation) => {
        readonly role: "group";
        readonly 'data-orientation': Orientation;
        }, string>;
        item: ExplicitBuilderReturn<[{
        update: (updater: Updater<string | string[] | undefined>, sideEffect?: ((newValue: string | string[] | undefined) => void) | undefined) => void;
        set: (this: void, value: string | string[] | undefined) => void;
        subscribe(this: void, run: Subscriber<string | string[] | undefined>, invalidate?: Invalidator<string | string[] | undefined> | undefined): Unsubscriber;
        }, Writable<boolean>, Writable<Orientation>, Writable<"single" | T>], (node: HTMLElement) => MeltActionReturn<ToggleGroupEvents['item']>, ([$value, $disabled, $orientation, $type]: [string | string[] | undefined, boolean, Orientation, "single" | T]) => (props: ToggleGroupItemProps) => {
        readonly disabled: true | undefined;
        readonly pressed: boolean;
        readonly 'data-orientation': Orientation;
        readonly 'data-disabled': true | undefined;
        readonly 'data-state': "on" | "off";
        readonly 'data-value': string;
        readonly 'aria-pressed': boolean;
        readonly type: "button";
        readonly role: "radio" | undefined;
        readonly tabindex: 0 | -1;
        }, string>;
    };
    states: {
        value: {
            update: (updater: Updater<string | string[] | undefined>, sideEffect?: ((newValue: string | string[] | undefined) => void) | undefined) => void;
            set: (this: void, value: string | string[] | undefined) => void;
            subscribe(this: void, run: Subscriber<string | string[] | undefined>, invalidate?: Invalidator<string | string[] | undefined> | undefined): Unsubscriber;
        };
    };
    helpers: {
        isPressed: Readable<(itemValue: string) => boolean>;
    };
    options: {
        disabled: Writable<boolean>;
        type: Writable<"single" | T>;
        onValueChange?: Writable<ChangeFn<string | string[] | undefined> | undefined> | undefined;
        defaultValue: Writable<string | (T extends "single" ? string : string[])>;
        loop: Writable<boolean>;
        orientation: Writable<Orientation>;
        rovingFocus: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreateToggleGroupProps<T extends ToggleGroupType = 'single'> = {
    defaultValue?: T extends 'single' ? string : string[];
    value?: Writable<string | string[] | undefined>;
    onValueChange?: ChangeFn<string | string[] | undefined>;
    type?: T;
    disabled?: boolean;
    rovingFocus?: boolean;
    loop?: boolean;
    orientation?: Orientation;
};

// @public (undocumented)
export type CreateToggleProps = {
    disabled?: boolean;
    defaultPressed?: boolean;
    pressed?: Writable<boolean>;
    onPressedChange?: ChangeFn<boolean>;
};

// @public (undocumented)
export const createToolbar: (props?: CreateToolbarProps) => {
    elements: {
        root: ExplicitBuilderReturn<Writable<Orientation>, Action<any, any, Record<never, any>>, ($orientation: Orientation) => {
        role: string;
        'data-orientation': Orientation;
        }, string>;
        button: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<ToolbarEvents['button']>, () => {
        readonly role: "button";
        readonly type: "button";
        readonly tabIndex: -1;
        }, string>;
        separator: ExplicitBuilderReturn<Writable<Orientation>, Action<any, any, Record<never, any>>, ($orientation: Orientation) => {
        readonly role: "separator";
        readonly 'data-orientation': "horizontal" | "vertical";
        readonly 'aria-orientation': "horizontal" | "vertical";
        }, string>;
        link: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<ToolbarEvents['link']>, () => {
        readonly role: "link";
        readonly 'data-melt-toolbar-item': "";
        readonly tabIndex: -1;
        }, string>;
    };
    builders: {
        createToolbarGroup: <T extends ToolbarGroupType = "single">(props?: CreateToolbarGroupProps<T> | undefined) => {
            elements: {
                group: ExplicitBuilderReturn<Writable<Orientation>, Action<any, any, Record<never, any>>, ($orientation: Orientation) => {
                readonly role: "group";
                readonly 'data-orientation': Orientation;
                }, string>;
                item: ExplicitBuilderReturn<[Writable<boolean>, Writable<"single" | T>, {
                update: (updater: Updater<string | string[] | undefined>, sideEffect?: ((newValue: string | string[] | undefined) => void) | undefined) => void;
                set: (this: void, value: string | string[] | undefined) => void;
                subscribe(this: void, run: Subscriber<string | string[] | undefined>, invalidate?: Invalidator<string | string[] | undefined> | undefined): Unsubscriber;
                }, Writable<Orientation>], (node: HTMLElement) => MeltActionReturn<ToolbarEvents['item']>, ([$disabled, $type, $value, $orientation]: [boolean, "single" | T, string | string[] | undefined, Orientation]) => (props: ToolbarGroupItemProps) => {
                readonly disabled: true | undefined;
                readonly pressed: boolean;
                readonly 'data-orientation': Orientation;
                readonly 'data-disabled': true | undefined;
                readonly 'data-value': string;
                readonly 'data-state': "on" | "off";
                readonly 'aria-pressed': boolean;
                readonly type: "button";
                readonly role: "radio" | undefined;
                readonly 'data-melt-toolbar-item': "";
                }, string>;
            };
            states: {
                value: {
                    update: (updater: Updater<string | string[] | undefined>, sideEffect?: ((newValue: string | string[] | undefined) => void) | undefined) => void;
                    set: (this: void, value: string | string[] | undefined) => void;
                    subscribe(this: void, run: Subscriber<string | string[] | undefined>, invalidate?: Invalidator<string | string[] | undefined> | undefined): Unsubscriber;
                };
            };
            helpers: {
                isPressed: Readable<(itemValue: string) => boolean>;
            };
            options: {
                defaultValue?: Writable<(T extends "single" ? string : string[]) | undefined> | undefined;
                value?: Writable<Writable<string | string[] | undefined> | undefined> | undefined;
                onValueChange?: Writable<ChangeFn<string | string[] | undefined> | undefined> | undefined;
                type: Writable<"single" | T>;
                disabled: Writable<boolean>;
            };
        };
    };
    options: {
        loop: Writable<boolean>;
        orientation: Writable<Orientation>;
    };
};

// @public (undocumented)
export type CreateToolbarGroupProps<T extends ToolbarGroupType = 'single'> = {
    defaultValue?: T extends 'single' ? string : string[];
    value?: Writable<string | string[] | undefined>;
    onValueChange?: ChangeFn<string | string[] | undefined>;
    type?: T;
    disabled?: boolean;
};

// @public (undocumented)
export type CreateToolbarProps = {
    loop?: boolean;
    orientation?: Orientation;
};

// @public (undocumented)
export function createTooltip(props?: CreateTooltipProps): {
    ids: {
        readonly content: string;
        readonly trigger: string;
    };
    elements: {
        trigger: ExplicitBuilderReturn<Stores | undefined, (node: HTMLElement) => MeltActionReturn<TooltipEvents['trigger']>, () => {
        'aria-describedby': string;
        id: string;
        }, string>;
        content: ExplicitBuilderReturn<[Readable<boolean>, Writable<string | HTMLElement | null>], (node: HTMLElement) => MeltActionReturn<TooltipEvents['content']>, ([$isVisible, $portal]: [boolean, string | HTMLElement | null]) => {
        role: string;
        hidden: boolean | undefined;
        tabindex: number;
        style: string;
        id: string;
        'data-portal': string | undefined;
        }, string>;
        arrow: ExplicitBuilderReturn<Writable<number>, Action<any, any, Record<never, any>>, ($arrowSize: number) => {
        'data-arrow': boolean;
        style: string;
        }, string>;
    };
    states: {
        open: {
            update: (updater: Updater<boolean>, sideEffect?: ((newValue: boolean) => void) | undefined) => void;
            set: (this: void, value: boolean) => void;
            subscribe(this: void, run: Subscriber<boolean>, invalidate?: Invalidator<boolean> | undefined): Unsubscriber;
        };
    };
    options: {
        forceVisible: Writable<boolean>;
        defaultOpen: Writable<boolean>;
        onOpenChange?: Writable<ChangeFn<boolean> | undefined> | undefined;
        portal: Writable<string | HTMLElement | null>;
        positioning: Writable<FloatingConfig | {
            placement: "bottom";
        }>;
        arrowSize: Writable<number>;
        closeOnEscape: Writable<boolean>;
        group: Writable<string | boolean | undefined>;
        openDelay: Writable<number>;
        closeDelay: Writable<number>;
        closeOnPointerDown: Writable<boolean>;
        disableHoverableContent: Writable<boolean>;
    };
};

// @public (undocumented)
export type CreateTooltipProps = {
    positioning?: FloatingConfig;
    arrowSize?: number;
    defaultOpen?: boolean;
    open?: Writable<boolean>;
    onOpenChange?: ChangeFn<boolean>;
    closeOnPointerDown?: boolean;
    openDelay?: number;
    closeDelay?: number;
    forceVisible?: boolean;
    closeOnEscape?: boolean;
    disableHoverableContent?: boolean;
    group?: boolean | string;
    portal?: HTMLElement | string | null;
};

// @public (undocumented)
export function createTreeView(args?: CreateTreeViewProps): {
    ids: {
        tree: string;
    };
    elements: {
        tree: ExplicitBuilderReturn<Stores | undefined, Action<any, any, Record<never, any>>, () => {
        readonly role: "tree";
        readonly 'data-melt-id': string;
        }, string>;
        item: ExplicitBuilderReturn<[{
        update: (updater: Updater<string[]>, sideEffect?: ((newValue: string[]) => void) | undefined) => void;
        set: (this: void, value: string[]) => void;
        subscribe(this: void, run: Subscriber<string[]>, invalidate?: Invalidator<string[]> | undefined): Unsubscriber;
        }, Readable<string | null | undefined>, Writable<string | null>], (node: HTMLElement) => MeltActionReturn<TreeEvents['item']>, ([$expanded, $selectedId, $lastFocusedId]: [string[], string | null | undefined, string | null]) => (opts: {
        id: string;
        hasChildren?: boolean;
        }) => {
        role: string;
        'aria-selected': boolean;
        'data-id': string;
        tabindex: number;
        'aria-expanded': boolean | undefined;
        }, string>;
        group: ExplicitBuilderReturn<[{
        update: (updater: Updater<string[]>, sideEffect?: ((newValue: string[]) => void) | undefined) => void;
        set: (this: void, value: string[]) => void;
        subscribe(this: void, run: Subscriber<string[]>, invalidate?: Invalidator<string[]> | undefined): Unsubscriber;
        }], Action<any, any, Record<never, any>>, ([$expanded]: [string[]]) => (opts: {
        id: string;
        }) => {
        role: string;
        'data-group-id': string;
        hidden: boolean | undefined;
        style: string;
        }, string>;
    };
    states: {
        expanded: {
            update: (updater: Updater<string[]>, sideEffect?: ((newValue: string[]) => void) | undefined) => void;
            set: (this: void, value: string[]) => void;
            subscribe(this: void, run: Subscriber<string[]>, invalidate?: Invalidator<string[]> | undefined): Unsubscriber;
        };
        selectedItem: Writable<HTMLElement | null>;
    };
    helpers: {
        isExpanded: Readable<(itemId: string) => boolean>;
        isSelected: Readable<(itemId: string) => boolean>;
    };
};

// @public (undocumented)
export type CreateTreeViewProps = {
    forceVisible?: boolean;
    defaultExpanded?: string[];
    expanded?: Writable<string[]>;
    onExpandedChange?: ChangeFn<string[]>;
};

// @public (undocumented)
export type Dialog = BuilderReturn<typeof createDialog>;

// @public (undocumented)
export type DialogComponentEvents = MeltComponentEvents<DialogEvents>;

// @public (undocumented)
export type DialogElements = Dialog['elements'];

// @public (undocumented)
export type DialogOptions = Dialog['options'];

// @public (undocumented)
export type DialogStates = Dialog['states'];

// @public (undocumented)
export type DropdownMenu = BuilderReturn<typeof createDropdownMenu>;

// @public (undocumented)
export type DropdownMenuBuilders = DropdownMenu['builders'];

// Warning: (ae-forgotten-export) The symbol "DropdownMenuEvents" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type DropdownMenuComponentEvents = MeltComponentEvents<DropdownMenuEvents>;

// @public (undocumented)
export type DropdownMenuElements = DropdownMenu['elements'];

// @public (undocumented)
export type DropdownMenuItemProps = _Menu['item'];

// @public (undocumented)
export type DropdownMenuOptions = DropdownMenu['options'];

// @public (undocumented)
export type DropdownMenuRadioGroup = BuilderReturn<DropdownMenuBuilders['createMenuRadioGroup']>;

// @public (undocumented)
export type DropdownMenuRadioGroupElements = DropdownMenuRadioGroup['elements'];

// @public (undocumented)
export type DropdownMenuRadioGroupHelpers = DropdownMenuRadioGroup['helpers'];

// @public (undocumented)
export type DropdownMenuRadioGroupStates = DropdownMenuRadioGroup['states'];

// @public (undocumented)
export type DropdownMenuRadioItemActionProps = _Menu['radioItemAction'];

// @public (undocumented)
export type DropdownMenuRadioItemProps = _Menu['radioItem'];

// @public (undocumented)
export type DropdownMenuStates = DropdownMenu['states'];

// @public (undocumented)
export type DropdownMenuSubmenu = BuilderReturn<DropdownMenuBuilders['createSubmenu']>;

// @public (undocumented)
export type DropdownMenuSubmenuElements = DropdownMenuSubmenu['elements'];

// @public (undocumented)
export type DropdownMenuSubmenuOptions = DropdownMenuSubmenu['options'];

// @public (undocumented)
export type DropdownMenuSubmenuStates = DropdownMenuSubmenu['states'];

// @public (undocumented)
export type ElementHeadingLU = {
    [key: number]: number;
};

// @public (undocumented)
export type Ellipsis = {
    type: 'ellipsis';
};

// @public (undocumented)
export type EmptyType = Record<never, never>;

// @public (undocumented)
export type GetPageItemsArgs = {
    totalPages: number;
    siblingCount?: number;
    page?: number;
};

// @public (undocumented)
export type Heading = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';

// @public (undocumented)
export type HeadingFilterFn = (heading: HTMLHeadingElement) => boolean;

// @public (undocumented)
export type HeadingParentsLU = {
    [key: number]: number[] | null;
};

// Warning: (ae-forgotten-export) The symbol "imageLoadingStatus" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ImageLoadingStatus = (typeof imageLoadingStatus)[number];

// @public (undocumented)
export const INTERACTION_KEYS: string[];

// @public (undocumented)
export type ItemDescription = {
    hasChildren: boolean;
    childrenIdxs: number[];
};

// @public (undocumented)
export type Label = BuilderReturn<typeof createLabel>;

// @public (undocumented)
export type LabelComponentEvents = MeltComponentEvents<LabelEvents>;

// @public (undocumented)
export type LabelElements = Label['elements'];

// @public (undocumented)
export type LinkPreview = BuilderReturn<typeof createLinkPreview>;

// @public (undocumented)
export type LinkPreviewComponentEvents = MeltComponentEvents<LinkPreviewEvents>;

// @public (undocumented)
export type LinkPreviewElements = LinkPreview['elements'];

// @public (undocumented)
export type LinkPreviewOptions = LinkPreview['options'];

// @public (undocumented)
export type LinkPreviewStates = LinkPreview['states'];

// @public (undocumented)
type ListboxOption<Value = unknown> = {
    value: Value;
    label?: string;
};
export { ListboxOption as ComboboxOption }
export { ListboxOption as SelectOption }

// @public (undocumented)
type ListboxOptionProps<Value = unknown> = ListboxOption<Value> & {
    disabled?: boolean;
};
export { ListboxOptionProps as ComboboxOptionProps }
export { ListboxOptionProps as SelectOptionProps }

// @public (undocumented)
type ListboxSelected<Multiple extends boolean, Value> = WhenTrue<Multiple, ListboxOption<Value>[], ListboxOption<Value>>;
export { ListboxSelected as ComboboxSelected }
export { ListboxSelected as SelectSelected }

// Warning: (ae-forgotten-export) The symbol "SomeBuilder" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "GetActionAttributes" needs to be exported by the entry point index.d.ts
//
// @public
export function melt<Builder extends SomeBuilder<Element, Param, A>, Element extends HTMLElement, Attributes extends GetActionAttributes<Builder>, A extends Record<string, any>, Param = never>(node: Element, params: Builder): ActionReturn<Builder, Attributes>;

// @public (undocumented)
export type Menubar = BuilderReturn<typeof createMenubar>;

// @public (undocumented)
export type MenubarBuilders = Menubar['builders'];

// @public (undocumented)
export type MenubarComponentEvents = MeltComponentEvents<MenubarEvents>;

// @public (undocumented)
export type MenubarElements = Menubar['elements'];

// @public (undocumented)
export type MenubarMenu = BuilderReturn<MenubarBuilders['createMenu']>;

// @public (undocumented)
export type MenubarMenuBuilders = MenubarMenu['builders'];

// @public (undocumented)
export type MenubarMenuElements = MenubarMenu['elements'];

// @public (undocumented)
export type MenubarMenuItemProps = _Menu['item'];

// @public (undocumented)
export type MenubarMenuOptions = MenubarMenu['options'];

// @public (undocumented)
export type MenubarMenuRadioGroup = BuilderReturn<MenubarMenuBuilders['createMenuRadioGroup']>;

// @public (undocumented)
export type MenubarMenuRadioGroupElements = MenubarMenuRadioGroup['elements'];

// @public (undocumented)
export type MenubarMenuRadioGroupHelpers = MenubarMenuRadioGroup['helpers'];

// @public (undocumented)
export type MenubarMenuRadioGroupStates = MenubarMenuRadioGroup['states'];

// @public (undocumented)
export type MenubarMenuStates = MenubarMenu['states'];

// @public (undocumented)
export type MenubarMenuSubmenu = BuilderReturn<MenubarMenuBuilders['createSubmenu']>;

// @public (undocumented)
export type MenubarMenuSubmenuElements = MenubarMenuSubmenu['elements'];

// @public (undocumented)
export type MenubarMenuSubmenuOptions = MenubarMenuSubmenu['options'];

// @public (undocumented)
export type MenubarMenuSubmenuStates = MenubarMenuSubmenu['states'];

// @public (undocumented)
export type MenubarOptions = Menubar['options'];

// @public (undocumented)
export type MenubarRadioItemActionProps = _Menu['radioItemAction'];

// @public (undocumented)
export type MenubarRadioItemProps = _Menu['radioItem'];

// @public (undocumented)
export type Page = {
    type: 'page';
    value: number;
};

// @public (undocumented)
export type PageItem = (Page | Ellipsis) & {
    key: string;
};

// @public (undocumented)
export type Pagination = BuilderReturn<typeof createPagination>;

// @public (undocumented)
export type PaginationComponentEvents = MeltComponentEvents<PaginationEvents>;

// @public (undocumented)
export type PaginationElements = Pagination['elements'];

// @public (undocumented)
export type PaginationOptions = Pagination['options'];

// @public (undocumented)
export type PaginationStates = Pagination['states'];

// @public (undocumented)
export type PinInput = BuilderReturn<typeof createPinInput>;

// @public (undocumented)
export type PinInputComponentEvents = MeltComponentEvents<PinInputEvents>;

// @public (undocumented)
export type PinInputElements = PinInput['elements'];

// @public (undocumented)
export type PinInputHelpers = PinInput['helpers'];

// @public (undocumented)
export type PinInputOptions = PinInput['options'];

// @public (undocumented)
export type PinInputStates = PinInput['states'];

// @public (undocumented)
export type Popover = BuilderReturn<typeof createPopover>;

// @public (undocumented)
export type PopoverComponentEvents = MeltComponentEvents<PopoverEvents>;

// @public (undocumented)
export type PopoverElements = Popover['elements'];

// @public (undocumented)
export type PopoverOptions = Popover['options'];

// @public (undocumented)
export type PopoverStates = Popover['states'];

// @public (undocumented)
export type Progress = BuilderReturn<typeof createProgress>;

// @public (undocumented)
export type ProgressElements = Progress['elements'];

// @public (undocumented)
export type ProgressOptions = Progress['options'];

// @public (undocumented)
export type ProgressStates = Progress['states'];

// @public (undocumented)
export type RadioGroup = BuilderReturn<typeof createRadioGroup>;

// @public (undocumented)
export type RadioGroupComponentEvents = MeltComponentEvents<RadioGroupEvents>;

// @public (undocumented)
export type RadioGroupElements = RadioGroup['elements'];

// @public (undocumented)
export type RadioGroupHelpers = RadioGroup['helpers'];

// @public (undocumented)
export type RadioGroupItemProps = {
    value: string;
    disabled?: boolean;
} | string;

// @public (undocumented)
export type RadioGroupOptions = RadioGroup['options'];

// @public (undocumented)
export type RadioGroupStates = RadioGroup['states'];

// @public (undocumented)
export type RemoveTag = (tag: Tag) => (boolean | never) | Promise<boolean | never>;

// @public (undocumented)
export type ScrollBehaviour = 'smooth' | 'instant';

// @public (undocumented)
export type ScrollFn = (id: string) => void;

// @public (undocumented)
export type Select<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = BuilderReturn<typeof createSelect<Value, Multiple, S>>;

// Warning: (ae-forgotten-export) The symbol "SelectEvents" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type SelectComponentEvents = MeltComponentEvents<SelectEvents>;

// @public (undocumented)
export type SelectElements<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = Select<Value, Multiple, S>['elements'];

// @public (undocumented)
export type SelectHelpers<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = Select<Value, Multiple, S>['helpers'];

// @public (undocumented)
export type SelectOptions<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = Select<Value, Multiple, S>['options'];

// @public (undocumented)
export type SelectStates<Value = unknown, Multiple extends boolean = false, S extends ListboxSelected<Multiple, Value> = ListboxSelected<Multiple, Value>> = Select<Value, Multiple, S>['states'];

// @public (undocumented)
export type Separator = BuilderReturn<typeof createSeparator>;

// @public (undocumented)
export type SeparatorElements = Separator['elements'];

// @public (undocumented)
export type SeparatorOptions = Separator['options'];

// @public (undocumented)
export type Slider = BuilderReturn<typeof createSlider>;

// @public (undocumented)
export type SliderComponentEvents = MeltComponentEvents<SliderEvents>;

// @public (undocumented)
export type SliderElements = Slider['elements'];

// @public (undocumented)
export type SliderOptions = Slider['options'];

// @public (undocumented)
export type SliderStates = Slider['states'];

// @public (undocumented)
export type Switch = BuilderReturn<typeof createSwitch>;

// @public (undocumented)
export type SwitchComponentEvents = MeltComponentEvents<SwitchEvents>;

// @public (undocumented)
export type SwitchElements = Switch['elements'];

// @public (undocumented)
export type SwitchOptions = Switch['options'];

// @public (undocumented)
export type SwitchStates = Switch['states'];

// @public (undocumented)
export type TableOfContents = ReturnType<typeof createTableOfContents>;

// @public (undocumented)
export type TableOfContentsElements = TableOfContents['elements'];

// @public (undocumented)
export type TableOfContentsItem = {
    title: string;
    index: number;
    id: string;
    node: HTMLHeadingElement;
    children?: TableOfContentsItem[];
};

// @public (undocumented)
export type TableOfContentsStates = TableOfContents['states'];

// @public (undocumented)
export type Tabs = BuilderReturn<typeof createTabs>;

// @public (undocumented)
export type TabsComponentEvents = MeltComponentEvents<TabsEvents>;

// @public (undocumented)
export type TabsElements = Tabs['elements'];

// @public (undocumented)
export type TabsOptions = Tabs['options'];

// @public (undocumented)
export type TabsStates = Tabs['states'];

// @public (undocumented)
export type TabsTriggerProps = {
    value: string;
    disabled?: boolean;
} | string;

// @public (undocumented)
export type Tag = {
    id: string;
    value: string;
};

// @public (undocumented)
export type TagProps = {
    id: string;
    value: string;
    disabled?: boolean;
    editable?: boolean;
};

// @public (undocumented)
export type TagsInput = BuilderReturn<typeof createTagsInput>;

// @public (undocumented)
export type TagsInputComponentEvents = MeltComponentEvents<TagsInputEvents>;

// @public (undocumented)
export type TagsInputElements = TagsInput['elements'];

// @public (undocumented)
export type TagsInputHelpers = TagsInput['helpers'];

// @public (undocumented)
export type TagsInputOptions = TagsInput['options'];

// @public (undocumented)
export type TagsInputStates = TagsInput['states'];

// @public (undocumented)
export type Toast<T = object> = {
    id: string;
    ids: {
        content: string;
        title: string;
        description: string;
    };
    closeDelay: number;
    type: 'foreground' | 'background';
    data: T;
    timeout: number | null;
    createdAt: number;
    pausedAt?: number;
    pauseDuration: number;
    getPercentage: () => number;
};

// @public (undocumented)
export type ToastComponentEvents = MeltComponentEvents<ToastEvents>;

// @public (undocumented)
export type Toasts<T = object> = BuilderReturn<typeof createToaster<T>>;

// @public (undocumented)
export type ToastsElements<T = object> = BuilderReturn<typeof createToaster<T>>['elements'];

// @public (undocumented)
export type ToastsHelpers<T = object> = BuilderReturn<typeof createToaster<T>>['helpers'];

// @public (undocumented)
export type ToastsOptions<T = object> = BuilderReturn<typeof createToaster<T>>['options'];

// @public (undocumented)
export type ToastsStates<T = object> = BuilderReturn<typeof createToaster<T>>['states'];

// @public (undocumented)
export type Toggle = BuilderReturn<typeof createToggle>;

// @public (undocumented)
export type ToggleBuilders = Toggle['states'];

// @public (undocumented)
export type ToggleComponentEvents = MeltComponentEvents<ToggleEvents>;

// @public (undocumented)
export type ToggleElements = Toggle['elements'];

// @public (undocumented)
export type ToggleGroup<T extends ToggleGroupType = 'single'> = BuilderReturn<typeof createToggleGroup<T>>;

// @public (undocumented)
export type ToggleGroupComponentEvents = MeltComponentEvents<ToggleGroupEvents>;

// @public (undocumented)
export type ToggleGroupElements<T extends ToggleGroupType = 'single'> = BuilderReturn<typeof createToggleGroup<T>>['elements'];

// @public (undocumented)
export type ToggleGroupHelpers<T extends ToggleGroupType = 'single'> = BuilderReturn<typeof createToggleGroup<T>>['helpers'];

// @public (undocumented)
export type ToggleGroupItemProps = {
    value: string;
    disabled?: boolean;
} | string;

// @public (undocumented)
export type ToggleGroupOptions<T extends ToggleGroupType = 'single'> = BuilderReturn<typeof createToggleGroup<T>>['options'];

// @public (undocumented)
export type ToggleGroupStates<T extends ToggleGroupType = 'single'> = BuilderReturn<typeof createToggleGroup<T>>['states'];

// @public (undocumented)
export type ToggleGroupType = 'single' | 'multiple';

// @public (undocumented)
export type ToggleOptions = Toggle['options'];

// @public (undocumented)
export type Toolbar = BuilderReturn<typeof createToolbar>;

// @public (undocumented)
export type ToolbarBuilders = Toolbar['builders'];

// @public (undocumented)
export type ToolbarComponentEvents = MeltComponentEvents<ToolbarEvents>;

// @public (undocumented)
export type ToolbarElements = Toolbar['elements'];

// @public (undocumented)
export type ToolbarGroup = BuilderReturn<ToolbarBuilders['createToolbarGroup']>;

// @public (undocumented)
export type ToolbarGroupElements = ToolbarGroup['elements'];

// @public (undocumented)
export type ToolbarGroupHelpers = ToolbarGroup['helpers'];

// @public (undocumented)
export type ToolbarGroupItemProps = {
    value: string;
    disabled?: boolean;
} | string;

// @public (undocumented)
export type ToolbarGroupOptions = ToolbarGroup['options'];

// @public (undocumented)
export type ToolbarGroupStates = ToolbarGroup['states'];

// @public (undocumented)
export type ToolbarGroupType = 'single' | 'multiple';

// @public (undocumented)
export type ToolbarOptions = Toolbar['options'];

// @public (undocumented)
export type Tooltip = BuilderReturn<typeof createTooltip>;

// @public (undocumented)
export type TooltipComponentEvents = MeltComponentEvents<TooltipEvents>;

// @public (undocumented)
export type TooltipElements = Tooltip['elements'];

// @public (undocumented)
export type TooltipOptions = Tooltip['options'];

// @public (undocumented)
export type TooltipStates = Tooltip['states'];

// @public (undocumented)
export type TreeParts = 'label' | 'item' | 'group';

// @public (undocumented)
export type TreeView = ReturnType<typeof createTreeView>;

// @public (undocumented)
export type TreeViewElements = TreeView['elements'];

// @public (undocumented)
export type TreeViewHelpers = TreeView['helpers'];

// @public (undocumented)
export type TreeViewStates = TreeView['states'];

// @public (undocumented)
export type UpdateTag = (tag: Tag) => (Tag | never) | Promise<Tag | never>;

// Warnings were encountered during analysis:
//
// dist/builders/accordion/create.d.ts:13:9 - (ae-forgotten-export) The symbol "ExplicitBuilderReturn" needs to be exported by the entry point index.d.ts
// dist/builders/accordion/create.d.ts:24:9 - (ae-forgotten-export) The symbol "MeltActionReturn" needs to be exported by the entry point index.d.ts
// dist/builders/accordion/create.d.ts:54:9 - (ae-forgotten-export) The symbol "WhenTrue" needs to be exported by the entry point index.d.ts
// dist/builders/accordion/types.d.ts:38:5 - (ae-forgotten-export) The symbol "AccordionValue" needs to be exported by the entry point index.d.ts
// dist/builders/accordion/types.d.ts:51:5 - (ae-forgotten-export) The symbol "ChangeFn" needs to be exported by the entry point index.d.ts
// dist/builders/combobox/create.d.ts:145:9 - (ae-forgotten-export) The symbol "FloatingConfig" needs to be exported by the entry point index.d.ts
// dist/builders/context-menu/create.d.ts:38:9 - (ae-forgotten-export) The symbol "Orientation" needs to be exported by the entry point index.d.ts
// dist/builders/context-menu/create.d.ts:60:9 - (ae-forgotten-export) The symbol "_CreateSubmenuProps" needs to be exported by the entry point index.d.ts
// dist/builders/context-menu/create.d.ts:110:9 - (ae-forgotten-export) The symbol "_CheckboxItemProps" needs to be exported by the entry point index.d.ts
// dist/builders/context-menu/create.d.ts:136:9 - (ae-forgotten-export) The symbol "_CreateRadioGroupProps" needs to be exported by the entry point index.d.ts
// dist/builders/context-menu/create.d.ts:141:17 - (ae-forgotten-export) The symbol "_RadioItemProps" needs to be exported by the entry point index.d.ts
// dist/builders/context-menu/create.d.ts:173:9 - (ae-forgotten-export) The symbol "TextDirection" needs to be exported by the entry point index.d.ts
// dist/builders/dialog/create.d.ts:25:9 - (ae-forgotten-export) The symbol "DialogEvents" needs to be exported by the entry point index.d.ts
// dist/builders/label/create.d.ts:6:9 - (ae-forgotten-export) The symbol "LabelEvents" needs to be exported by the entry point index.d.ts
// dist/builders/link-preview/create.d.ts:12:9 - (ae-forgotten-export) The symbol "LinkPreviewEvents" needs to be exported by the entry point index.d.ts
// dist/builders/menubar/create.d.ts:14:13 - (ae-forgotten-export) The symbol "noop" needs to be exported by the entry point index.d.ts
// dist/builders/menubar/create.d.ts:28:17 - (ae-forgotten-export) The symbol "MenubarEvents" needs to be exported by the entry point index.d.ts
// dist/builders/pagination/create.d.ts:10:9 - (ae-forgotten-export) The symbol "PaginationEvents" needs to be exported by the entry point index.d.ts
// dist/builders/pin-input/create.d.ts:18:9 - (ae-forgotten-export) The symbol "PinInputEvents" needs to be exported by the entry point index.d.ts
// dist/builders/popover/create.d.ts:11:9 - (ae-forgotten-export) The symbol "PopoverEvents" needs to be exported by the entry point index.d.ts
// dist/builders/radio-group/create.d.ts:12:9 - (ae-forgotten-export) The symbol "RadioGroupEvents" needs to be exported by the entry point index.d.ts
// dist/builders/slider/create.d.ts:17:9 - (ae-forgotten-export) The symbol "SliderEvents" needs to be exported by the entry point index.d.ts
// dist/builders/switch/create.d.ts:7:9 - (ae-forgotten-export) The symbol "SwitchEvents" needs to be exported by the entry point index.d.ts
// dist/builders/tabs/create.d.ts:15:9 - (ae-forgotten-export) The symbol "TabsEvents" needs to be exported by the entry point index.d.ts
// dist/builders/tags-input/create.d.ts:11:9 - (ae-forgotten-export) The symbol "TagsInputEvents" needs to be exported by the entry point index.d.ts
// dist/builders/toast/create.d.ts:7:9 - (ae-forgotten-export) The symbol "ToastEvents" needs to be exported by the entry point index.d.ts
// dist/builders/toast/create.d.ts:35:9 - (ae-forgotten-export) The symbol "PortalConfig" needs to be exported by the entry point index.d.ts
// dist/builders/toggle-group/create.d.ts:11:9 - (ae-forgotten-export) The symbol "ToggleGroupEvents" needs to be exported by the entry point index.d.ts
// dist/builders/toggle/create.d.ts:7:9 - (ae-forgotten-export) The symbol "ToggleEvents" needs to be exported by the entry point index.d.ts
// dist/builders/toolbar/create.d.ts:11:9 - (ae-forgotten-export) The symbol "ToolbarEvents" needs to be exported by the entry point index.d.ts
// dist/builders/tooltip/create.d.ts:12:9 - (ae-forgotten-export) The symbol "TooltipEvents" needs to be exported by the entry point index.d.ts
// dist/builders/tree/create.d.ts:15:9 - (ae-forgotten-export) The symbol "TreeEvents" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
